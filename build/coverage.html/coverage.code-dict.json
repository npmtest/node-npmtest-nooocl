{"/home/travis/build/npmtest/node-npmtest-nooocl/test.js":"/* istanbul instrument in package npmtest_nooocl */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        switch (local.modeJs) {\n        // re-init local from window.local\n        case 'browser':\n            local = local.global.utility2.objectSetDefault(\n                local.global.utility2_rollup || local.global.local,\n                local.global.utility2\n            );\n            break;\n        // re-init local from example.js\n        case 'node':\n            local = (local.global.utility2_rollup || require('utility2'))\n                .requireExampleJsFromReadme();\n            break;\n        }\n        // export local\n        local.global.local = local;\n    }());\n\n\n\n    // run shared js-env code - function\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - function\n    case 'browser':\n        break;\n\n\n\n    // run node js-env code - function\n    case 'node':\n        break;\n    }\n\n\n\n    // run shared js-env code - post-init\n    (function () {\n        return;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // run browser js-env code - post-init\n    case 'browser':\n        local.testCase_browser_nullCase = local.testCase_browser_nullCase || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test browsers's null-case handling-behavior-behavior\n         */\n            onError(null, options);\n        };\n\n        // run tests\n        local.nop(local.modeTest &&\n            document.querySelector('#testRunButton1') &&\n            document.querySelector('#testRunButton1').click());\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        local.testCase_buildApidoc_default = local.testCase_buildApidoc_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApidoc's default handling-behavior-behavior\n         */\n            options = { modulePathList: module.paths };\n            local.buildApidoc(options, onError);\n        };\n\n        local.testCase_buildApp_default = local.testCase_buildApp_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildApp's default handling-behavior-behavior\n         */\n            local.testCase_buildReadme_default(options, local.onErrorThrow);\n            local.testCase_buildLib_default(options, local.onErrorThrow);\n            local.testCase_buildTest_default(options, local.onErrorThrow);\n            local.testCase_buildCustomOrg_default(options, local.onErrorThrow);\n            options = [];\n            local.buildApp(options, onError);\n        };\n\n        local.testCase_buildCustomOrg_default = local.testCase_buildCustomOrg_default ||\n            function (options, onError) {\n            /*\n             * this function will test buildCustomOrg's default handling-behavior\n             */\n                options = {};\n                local.buildCustomOrg(options, onError);\n            };\n\n        local.testCase_buildLib_default = local.testCase_buildLib_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildLib's default handling-behavior\n         */\n            options = {};\n            local.buildLib(options, onError);\n        };\n\n        local.testCase_buildReadme_default = local.testCase_buildReadme_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildReadme's default handling-behavior-behavior\n         */\n            options = {};\n            local.buildReadme(options, onError);\n        };\n\n        local.testCase_buildTest_default = local.testCase_buildTest_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test buildTest's default handling-behavior\n         */\n            options = {};\n            local.buildTest(options, onError);\n        };\n\n        local.testCase_webpage_default = local.testCase_webpage_default || function (\n            options,\n            onError\n        ) {\n        /*\n         * this function will test webpage's default handling-behavior\n         */\n            options = { modeCoverageMerge: true, url: local.serverLocalHost + '?modeTest=1' };\n            local.browserTest(options, onError);\n        };\n\n        // run test-server\n        local.testRunServer(local);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nooocl/lib.npmtest_nooocl.js":"/* istanbul instrument in package npmtest_nooocl */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || local;\n        // init lib\n        local.local = local.npmtest_nooocl = local;\n        // init exports\n        if (local.modeJs === 'browser') {\n            local.global.utility2_npmtest_nooocl = local;\n        } else {\n            module.exports = local;\n            module.exports.__dirname = __dirname;\n            module.exports.module = module;\n        }\n    }());\n}());\n","/home/travis/build/npmtest/node-npmtest-nooocl/example.js":"/*\nexample.js\n\nquickstart example\n\ninstruction\n    1. save this script as example.js\n    2. run the shell command:\n        $ npm install npmtest-nooocl && PORT=8081 node example.js\n    3. play with the browser-demo on http://127.0.0.1:8081\n*/\n\n\n\n/* istanbul instrument in package npmtest_nooocl */\n/*jslint\n    bitwise: true,\n    browser: true,\n    maxerr: 8,\n    maxlen: 96,\n    node: true,\n    nomen: true,\n    regexp: true,\n    stupid: true\n*/\n(function () {\n    'use strict';\n    var local;\n\n\n\n    // run shared js-env code - pre-init\n    (function () {\n        // init local\n        local = {};\n        // init modeJs\n        local.modeJs = (function () {\n            try {\n                return typeof navigator.userAgent === 'string' &&\n                    typeof document.querySelector('body') === 'object' &&\n                    typeof XMLHttpRequest.prototype.open === 'function' &&\n                    'browser';\n            } catch (errorCaughtBrowser) {\n                return module.exports &&\n                    typeof process.versions.node === 'string' &&\n                    typeof require('http').createServer === 'function' &&\n                    'node';\n            }\n        }());\n        // init global\n        local.global = local.modeJs === 'browser'\n            ? window\n            : global;\n        // init utility2_rollup\n        local = local.global.utility2_rollup || (local.modeJs === 'browser'\n            ? local.global.utility2_npmtest_nooocl\n            : global.utility2_moduleExports);\n        // export local\n        local.global.local = local;\n    }());\n    switch (local.modeJs) {\n\n\n\n    // post-init\n    // run browser js-env code - post-init\n    /* istanbul ignore next */\n    case 'browser':\n        local.testRunBrowser = function (event) {\n            if (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('onreset'))) {\n                // reset output\n                Array.from(\n                    document.querySelectorAll('body > .resettable')\n                ).forEach(function (element) {\n                    switch (element.tagName) {\n                    case 'INPUT':\n                    case 'TEXTAREA':\n                        element.value = '';\n                        break;\n                    default:\n                        element.textContent = '';\n                    }\n                });\n            }\n            switch (event && event.currentTarget && event.currentTarget.id) {\n            case 'testRunButton1':\n                // show tests\n                if (document.querySelector('#testReportDiv1').style.display === 'none') {\n                    document.querySelector('#testReportDiv1').style.display = 'block';\n                    document.querySelector('#testRunButton1').textContent =\n                        'hide internal test';\n                    local.modeTest = true;\n                    local.testRunDefault(local);\n                // hide tests\n                } else {\n                    document.querySelector('#testReportDiv1').style.display = 'none';\n                    document.querySelector('#testRunButton1').textContent = 'run internal test';\n                }\n                break;\n            // custom-case\n            default:\n                break;\n            }\n            if (document.querySelector('#inputTextareaEval1') && (!event || (event &&\n                    event.currentTarget &&\n                    event.currentTarget.className &&\n                    event.currentTarget.className.includes &&\n                    event.currentTarget.className.includes('oneval')))) {\n                // try to eval input-code\n                try {\n                    /*jslint evil: true*/\n                    eval(document.querySelector('#inputTextareaEval1').value);\n                } catch (errorCaught) {\n                    console.error(errorCaught);\n                }\n            }\n        };\n        // log stderr and stdout to #outputTextareaStdout1\n        ['error', 'log'].forEach(function (key) {\n            console[key + '_original'] = console[key];\n            console[key] = function () {\n                var element;\n                console[key + '_original'].apply(console, arguments);\n                element = document.querySelector('#outputTextareaStdout1');\n                if (!element) {\n                    return;\n                }\n                // append text to #outputTextareaStdout1\n                element.value += Array.from(arguments).map(function (arg) {\n                    return typeof arg === 'string'\n                        ? arg\n                        : JSON.stringify(arg, null, 4);\n                }).join(' ') + '\\n';\n                // scroll textarea to bottom\n                element.scrollTop = element.scrollHeight;\n            };\n        });\n        // init event-handling\n        ['change', 'click', 'keyup'].forEach(function (event) {\n            Array.from(document.querySelectorAll('.on' + event)).forEach(function (element) {\n                element.addEventListener(event, local.testRunBrowser);\n            });\n        });\n        // run tests\n        local.testRunBrowser();\n        break;\n\n\n\n    // run node js-env code - post-init\n    /* istanbul ignore next */\n    case 'node':\n        // export local\n        module.exports = local;\n        // require modules\n        local.fs = require('fs');\n        local.http = require('http');\n        local.url = require('url');\n        // init assets\n        local.assetsDict = local.assetsDict || {};\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.index.template.html'] = '\\\n<!doctype html>\\n\\\n<html lang=\"en\">\\n\\\n<head>\\n\\\n<meta charset=\"UTF-8\">\\n\\\n<meta name=\"viewport\" content=\"width=device-width, initial-scale=1\">\\n\\\n<title>{{env.npm_package_name}} (v{{env.npm_package_version}})</title>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n    box-sizing: false,\\n\\\n    universal-selector: false\\n\\\n*/\\n\\\n* {\\n\\\n    box-sizing: border-box;\\n\\\n}\\n\\\nbody {\\n\\\n    background: #dde;\\n\\\n    font-family: Arial, Helvetica, sans-serif;\\n\\\n    margin: 2rem;\\n\\\n}\\n\\\nbody > * {\\n\\\n    margin-bottom: 1rem;\\n\\\n}\\n\\\n.utility2FooterDiv {\\n\\\n    margin-top: 20px;\\n\\\n    text-align: center;\\n\\\n}\\n\\\n</style>\\n\\\n<style>\\n\\\n/*csslint\\n\\\n*/\\n\\\ntextarea {\\n\\\n    font-family: monospace;\\n\\\n    height: 10rem;\\n\\\n    width: 100%;\\n\\\n}\\n\\\ntextarea[readonly] {\\n\\\n    background: #ddd;\\n\\\n}\\n\\\n</style>\\n\\\n</head>\\n\\\n<body>\\n\\\n<!-- utility2-comment\\n\\\n<div id=\"ajaxProgressDiv1\" style=\"background: #d00; height: 2px; left: 0; margin: 0; padding: 0; position: fixed; top: 0; transition: background 0.5s, width 1.5s; width: 25%;\"></div>\\n\\\nutility2-comment -->\\n\\\n<h1>\\n\\\n<!-- utility2-comment\\n\\\n    <a\\n\\\n        {{#if env.npm_package_homepage}}\\n\\\n        href=\"{{env.npm_package_homepage}}\"\\n\\\n        {{/if env.npm_package_homepage}}\\n\\\n        target=\"_blank\"\\n\\\n    >\\n\\\nutility2-comment -->\\n\\\n        {{env.npm_package_name}} (v{{env.npm_package_version}})\\n\\\n<!-- utility2-comment\\n\\\n    </a>\\n\\\nutility2-comment -->\\n\\\n</h1>\\n\\\n<h3>{{env.npm_package_description}}</h3>\\n\\\n<!-- utility2-comment\\n\\\n<h4><a download href=\"assets.app.js\">download standalone app</a></h4>\\n\\\n<button class=\"onclick onreset\" id=\"testRunButton1\">run internal test</button><br>\\n\\\n<div id=\"testReportDiv1\" style=\"display: none;\"></div>\\n\\\nutility2-comment -->\\n\\\n\\n\\\n\\n\\\n\\n\\\n<label>stderr and stdout</label>\\n\\\n<textarea class=\"resettable\" id=\"outputTextareaStdout1\" readonly></textarea>\\n\\\n<!-- utility2-comment\\n\\\n{{#if isRollup}}\\n\\\n<script src=\"assets.app.js\"></script>\\n\\\n{{#unless isRollup}}\\n\\\nutility2-comment -->\\n\\\n<script src=\"assets.utility2.rollup.js\"></script>\\n\\\n<script src=\"jsonp.utility2._stateInit?callback=window.utility2._stateInit\"></script>\\n\\\n<script src=\"assets.npmtest_nooocl.rollup.js\"></script>\\n\\\n<script src=\"assets.example.js\"></script>\\n\\\n<script src=\"assets.test.js\"></script>\\n\\\n<!-- utility2-comment\\n\\\n{{/if isRollup}}\\n\\\nutility2-comment -->\\n\\\n<div class=\"utility2FooterDiv\">\\n\\\n    [ this app was created with\\n\\\n    <a href=\"https://github.com/kaizhu256/node-utility2\" target=\"_blank\">utility2</a>\\n\\\n    ]\\n\\\n</div>\\n\\\n</body>\\n\\\n</html>\\n\\\n';\n        /* jslint-ignore-end */\n        if (local.templateRender) {\n            local.assetsDict['/'] = local.templateRender(\n                local.assetsDict['/assets.index.template.html'],\n                {\n                    env: local.objectSetDefault(local.env, {\n                        npm_package_description: 'the greatest app in the world!',\n                        npm_package_name: 'my-app',\n                        npm_package_nameAlias: 'my_app',\n                        npm_package_version: '0.0.1'\n                    })\n                }\n            );\n        } else {\n            local.assetsDict['/'] = local.assetsDict['/assets.index.template.html']\n                .replace((/\\{\\{env\\.(\\w+?)\\}\\}/g), function (match0, match1) {\n                    // jslint-hack\n                    String(match0);\n                    switch (match1) {\n                    case 'npm_package_description':\n                        return 'the greatest app in the world!';\n                    case 'npm_package_name':\n                        return 'my-app';\n                    case 'npm_package_nameAlias':\n                        return 'my_app';\n                    case 'npm_package_version':\n                        return '0.0.1';\n                    }\n                });\n        }\n        // run the cli\n        if (local.global.utility2_rollup || module !== require.main) {\n            break;\n        }\n        local.assetsDict['/assets.example.js'] =\n            local.assetsDict['/assets.example.js'] ||\n            local.fs.readFileSync(__filename, 'utf8');\n        // bug-workaround - long $npm_package_buildCustomOrg\n        /* jslint-ignore-begin */\n        local.assetsDict['/assets.npmtest_nooocl.rollup.js'] =\n            local.assetsDict['/assets.npmtest_nooocl.rollup.js'] ||\n            local.fs.readFileSync(\n                local.npmtest_nooocl.__dirname + '/lib.npmtest_nooocl.js',\n                'utf8'\n            ).replace((/^#!/), '//');\n        /* jslint-ignore-end */\n        local.assetsDict['/favicon.ico'] = local.assetsDict['/favicon.ico'] || '';\n        // if $npm_config_timeout_exit exists,\n        // then exit this process after $npm_config_timeout_exit ms\n        if (Number(process.env.npm_config_timeout_exit)) {\n            setTimeout(process.exit, Number(process.env.npm_config_timeout_exit));\n        }\n        // start server\n        if (local.global.utility2_serverHttp1) {\n            break;\n        }\n        process.env.PORT = process.env.PORT || '8081';\n        console.error('server starting on port ' + process.env.PORT);\n        local.http.createServer(function (request, response) {\n            request.urlParsed = local.url.parse(request.url);\n            if (local.assetsDict[request.urlParsed.pathname] !== undefined) {\n                response.end(local.assetsDict[request.urlParsed.pathname]);\n                return;\n            }\n            response.statusCode = 404;\n            response.end();\n        }).listen(process.env.PORT);\n        break;\n    }\n}());\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/index.js":"/*jslint node:true,nomen:true,vars:true,plusplus:true,white:true,unparam:true*/\r\n/*jshint onevar:true*/\r\n'use strict';\r\nmodule.exports = require('./lib');\r\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/index.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# NOOOCL API index\n\nPublic definitions of the NOOOCL library.\n*/\n\n\"use strict\";\n\nvar fastcall = require(\"fastcall\");\n\n// ## Exported stuff\nmodule.exports = {\n    // ### [CLHost](clHost.html)\n    // This is the entry point of interacting OpenCL runtime in NOOOCL.\n    CLHost: require(\"./clHost\"),\n\n    // ### [CLPlatform](clPlatform.html)\n    // Represents an OpenCL platform.\n    CLPlatform: require(\"./clPlatform\"),\n\n    // ### [CLDevice](clDevice.html)\n    // Represents an OpenCL device.\n    CLDevice: require(\"./clDevice\"),\n\n    // ### [CLContext](clContext.html)\n    // Represents an OpenCL context.\n    CLContext: require(\"./clContext\"),\n\n    CLBuffer: require(\"./clBuffer\"),\n    CLCommandQueue: require(\"./clCommandQueue\"),\n    CLUserEvent: require(\"./clUserEvent\"),\n    NDRange: require(\"./ndRange\"),\n    CLProgram: require(\"./clProgram\"),\n    CLKernel: require(\"./clKernel\"),\n    CLImage2D: require(\"./clImage2D\"),\n    CLImage3D: require(\"./clImage3D\"),\n    CLSampler: require(\"./clSampler\"),\n    CLError: require(\"./clError\"),\n    scope: fastcall.scope\n};\n\n/*\n## Additional stuff\n\n### [CLWrapper](clWrapper.html)\nBase class of OpenCL wrapper classes.\n*/","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clHost.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# CLHost class\n\nThis is the entry point of interacting OpenCL runtime in NOOOCL.\n\n**base:** Object\n\n**Properties:**\n- [supportedVersions (static)](#supportedversions)\n- [version](#version)\n- [cl](#cl)\n- [platformsCount](#platformscount)\n\n**Methods:**\n- [constructor](#constructor)\n- [createV11 (static)](#createv11)\n- [createV12 (static)](#createv12)\n- [getPlatforms](#getplatforms)\n*/\n\n\"use strict\";\nvar _ = require(\"lodash\");\nvar CL11 = require(\"./cl11\");\nvar CL12 = require(\"./cl12\");\nvar CLPlatform = require(\"./clPlatform\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar assert = require(\"assert\");\n\n/*\n## constructor\n\n**arguments:**\n- **version:** version of the OpenCL runtime, can be number value of 1.1 or 1.2.\n*/\nfunction CLHost(version) {\n    assert(_.includes(_.values(CLHost.supportedVersions), version), \"Argument 'version' is invalid or not supported.\");\n\n    // ## version\n    // version of the OpenCL runtime, can be number value of 1.1 or 1.2.\n    this.version = version;\n\n    // ## cl\n    // instance of the [CL11](cl11.html) or [CL12](cl12.html) class, depending the version of the OpenCL runtime.\n    this.cl = null;\n    if (version === CLHost.supportedVersions.cl11) {\n        this.cl = new CL11();\n    }\n    else if (version === CLHost.supportedVersions.cl12) {\n        this.cl = new CL12();\n    }\n    else {\n        throw new Error(\"Unknown version: \" + version);\n    }\n}\n\n// ## supportedVersions\n// Object defining the supported OpenCL runtime versions of the NOOOCL library\nCLHost.supportedVersions = {\n    cl11: 1.1,\n    cl12: 1.2\n};\n\nObject.defineProperties(CLHost.prototype, {\n    _nPlatformsCount: {\n        get: function () {\n            var num = ref.alloc(\"uint\");\n\n            // _OpenCL API:_ [clGetPlatformIDs](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformIDs.html)\n            var err = this.cl.imports.clGetPlatformIDs(0, null, num);\n\n            this.cl.checkError(err);\n            return num;\n        }\n    },\n    // ## platformsCount\n    // Number of OpenCL platforms available.\n    platformsCount: {\n        get: function () {\n            return this._nPlatformsCount.deref();\n        }\n    }\n});\n\n// ## createV11\n// Creates a host instance for the OpenCL 1.1 runtime.\nCLHost.createV11 = function () {\n    return new CLHost(CLHost.supportedVersions.cl11);\n};\n\n// ## createV12\n// Creates a host instance for the OpenCL 1.2 runtime if it is supported by the actual hardware.\nCLHost.createV12 = function () {\n    return new CLHost(CLHost.supportedVersions.cl12);\n};\n\n/* ## getPlatforms\nReturns OpenCL platforms available.\n\n**Result:**\n\nArray of [CLPlatform](clPlatform.html) instances.\n*/\nCLHost.prototype.getPlatforms = function () {\n    var i;\n    var count = this._nPlatformsCount;\n    var nCount = count.deref();\n    var plaformIds = new (this.cl.types.PlatformIdArray)(nCount);\n\n    // _OpenCL API:_ [clGetPlatformIDs](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetPlatformIDs.html)\n    var err = this.cl.imports.clGetPlatformIDs(plaformIds.length, plaformIds, count);\n\n    this.cl.checkError(err);\n    var platforms = [];\n    for (i = 0; i < nCount; i++) {\n        platforms.push(new CLPlatform(this.cl, plaformIds.get(i)));\n    }\n    return platforms;\n};\n\nmodule.exports = CLHost;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/cl11.js":"\"use strict\";\n\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar ffi = fastcall.ffi;\nvar types = require(\"./types\");\nvar defs = require(\"./clDefines\");\nvar CLError = require(\"./clError\");\n\nfunction CL11() {\n    this.types = types;\n    this.defs = defs;\n    this.version = 1.1;\n    this.libName = (process.platform === \"win32\") ? \"OpenCL\" : (process.platform === \"darwin\") ? \"/System/Library/Frameworks/OpenCL.framework/OpenCL\" : \"libOpenCL.so\";\n    this.imports = new ffi.Library(this.libName,\n        {\n            /* Platform APIs */\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetPlatformIDs(cl_uint          /* num_entries */,\n            //                 cl_platform_id * /* platforms */,\n            //                cl_uint *        /* num_platforms */) CL_API_SUFFIX__VERSION_1_0;\n            clGetPlatformIDs: [ref.types.int, [ref.types.uint, types.PlatformIdArray, ref.refType(ref.types.uint)]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetPlatformInfo(cl_platform_id   /* platform */,\n            //                  cl_platform_info /* param_name */,\n            //                  size_t           /* param_value_size */,\n            //                  void *           /* param_value */,\n            //                  size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetPlatformInfo: [ref.types.int, [types.PlatformId, types.PlatformInfo, ref.types.size_t, \"pointer\", ref.refType(ref.types.size_t)]],\n\n            /* Device APIs */\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetDeviceIDs(cl_platform_id   /* platform */,\n            //               cl_device_type   /* device_type */,\n            //               cl_uint          /* num_entries */,\n            //               cl_device_id *   /* devices */,\n            //               cl_uint *        /* num_devices */) CL_API_SUFFIX__VERSION_1_0;\n            clGetDeviceIDs: [ref.types.int, [types.PlatformId, types.DeviceType, ref.types.uint, types.DeviceIdArray, ref.refType(ref.types.uint)]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetDeviceInfo(cl_device_id    /* device */,\n            //                cl_device_info  /* param_name */,\n            //               size_t          /* param_value_size */,\n            //               void *          /* param_value */,\n            //               size_t *        /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetDeviceInfo: [ref.types.int, [types.PlatformId, types.DeviceInfo, ref.types.size_t, \"pointer\", ref.refType(ref.types.size_t)]],\n\n            /* Context APIs  */\n            //extern CL_API_ENTRY cl_context CL_API_CALL\n            //clCreateContext(const cl_context_properties * /* properties */,\n            //                cl_uint                 /* num_devices */,\n            //                const cl_device_id *    /* devices */,\n            //                void (CL_CALLBACK * /* pfn_notify */)(const char *, const void *, size_t, void *),\n            //                void *                  /* user_data */,\n            //                cl_int *                /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateContext: [\"pointer\", [types.ContextProperties, ref.types.uint, types.DeviceIdArray, ref.refType(types.CreateContextNotify), \"pointer\", types.ErrorCodeRet]],\n\n            //extern CL_API_ENTRY cl_context CL_API_CALL\n            //clCreateContextFromType(const cl_context_properties * /* properties */,\n            //                        cl_device_type          /* device_type */,\n            //                        void (CL_CALLBACK *     /* pfn_notify*/ )(const char *, const void *, size_t, void *),\n            //                        void *                  /* user_data */,\n            //                        cl_int *                /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateContextFromType: [\"pointer\", [types.ContextProperties, types.DeviceType, ref.refType(types.CreateContextNotify), \"pointer\", types.ErrorCodeRet]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainContext(cl_context /* context */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainContext: [\"int\", [types.Context]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseContext(cl_context /* context */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseContext: [\"int\", [types.Context]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetContextInfo(cl_context         /* context */,\n            //                 cl_context_info    /* param_name */,\n            //                 size_t             /* param_value_size */,\n            //                 void *             /* param_value */,\n            //                 size_t *           /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetContextInfo: [\"int\", [types.Context, types.ContextInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Command Queue APIs */\n            //extern CL_API_ENTRY cl_command_queue CL_API_CALL\n            //clCreateCommandQueue(cl_context                     /* context */,\n            //                     cl_device_id                   /* device */,\n            //                     cl_command_queue_properties    /* properties */,\n            //                     cl_int *                       /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateCommandQueue: [types.CommandQueue, [types.Context, types.DeviceId, types.CommandQueueProperties, ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainCommandQueue(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainCommandQueue: [\"int\", [types.CommandQueue]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseCommandQueue(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseCommandQueue: [\"int\", [types.CommandQueue]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetCommandQueueInfo(cl_command_queue      /* command_queue */,\n            //                      cl_command_queue_info /* param_name */,\n            //                      size_t                /* param_value_size */,\n            //                      void *                /* param_value */,\n            //                      size_t *              /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetCommandQueueInfo: [\"int\", [types.CommandQueue, types.CommandQueueInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Memory Object APIs */\n            //extern CL_API_ENTRY cl_mem CL_API_CALL\n            //clCreateBuffer(cl_context   /* context */,\n            //               cl_mem_flags /* flags */,\n            //               size_t       /* size */,\n            //               void *       /* host_ptr */,\n            //               cl_int *     /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateBuffer: [types.Mem, [types.Context, types.MemFlags, \"size_t\", \"pointer\", ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainMemObject(cl_mem /* memobj */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainMemObject: [\"int\", [types.Mem]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseMemObject(cl_mem /* memobj */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseMemObject: [\"int\", [types.Mem]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetSupportedImageFormats(cl_context           /* context */,\n            //                           cl_mem_flags         /* flags */,\n            //                           cl_mem_object_type   /* image_type */,\n            //                           cl_uint              /* num_entries */,\n            //                           cl_image_format *    /* image_formats */,\n            //                           cl_uint *            /* num_image_formats */) CL_API_SUFFIX__VERSION_1_0;\n            clGetSupportedImageFormats: [\"int\", [types.Context, types.MemFlags, types.MemObjectType, \"uint\", types.ImageFormatArray, ref.refType(\"uint\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetMemObjectInfo(cl_mem           /* memobj */,\n            //                   cl_mem_info      /* param_name */,\n            //                   size_t           /* param_value_size */,\n            //                   void *           /* param_value */,\n            //                   size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetMemObjectInfo: [\"int\", [types.Mem, types.MemInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetImageInfo(cl_mem           /* image */,\n            //               cl_image_info    /* param_name */,\n            //               size_t           /* param_value_size */,\n            //               void *           /* param_value */,\n            //               size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetImageInfo: [\"int\", [types.Mem, types.ImageInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Sampler APIs */\n            //extern CL_API_ENTRY cl_sampler CL_API_CALL\n            //clCreateSampler(cl_context          /* context */,\n            //                cl_bool             /* normalized_coords */,\n            //                cl_addressing_mode  /* addressing_mode */,\n            //                cl_filter_mode      /* filter_mode */,\n            //                cl_int *            /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateSampler: [types.Sampler, [types.Context, types.Bool, types.AddressingMode, types.FilterMode, ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainSampler(cl_sampler /* sampler */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainSampler: [\"int\", [types.Sampler]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseSampler(cl_sampler /* sampler */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseSampler: [\"int\", [types.Sampler]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetSamplerInfo(cl_sampler         /* sampler */,\n            //                 cl_sampler_info    /* param_name */,\n            //                 size_t             /* param_value_size */,\n            //                 void *             /* param_value */,\n            //                 size_t *           /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetSamplerInfo: [\"int\", [types.Sampler, types.SamplerInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Program Object APIs  */\n            //extern CL_API_ENTRY cl_program CL_API_CALL\n            //clCreateProgramWithSource(cl_context        /* context */,\n            //                          cl_uint           /* count */,\n            //                          const char **     /* strings */,\n            //                          const size_t *    /* lengths */,\n            //                          cl_int *          /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateProgramWithSource: [types.Program, [types.Context, \"uint\", types.StringArray, types.SizeTArray, ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_program CL_API_CALL\n            //clCreateProgramWithBinary(cl_context                     /* context */,\n            //                          cl_uint                        /* num_devices */,\n            //                          const cl_device_id *           /* device_list */,\n            //                          const size_t *                 /* lengths */,\n            //                          const unsigned char **         /* binaries */,\n            //                          cl_int *                       /* binary_status */,\n            //                          cl_int *                       /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateProgramWithBinary: [types.Program, [types.Context, \"uint\", types.DeviceIdArray, types.SizeTArray, types.Binaries, ref.refType(\"int\"), ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainProgram(cl_program /* program */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainProgram: [\"int\", [types.Program]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseProgram(cl_program /* program */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseProgram: [\"int\", [types.Program]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clBuildProgram(cl_program           /* program */,\n            //              cl_uint              /* num_devices */,\n            //              const cl_device_id * /* device_list */,\n            //              const char *         /* options */,\n            //              void (CL_CALLBACK *  /* pfn_notify */)(cl_program /* program */, void * /* user_data */),\n            //              void *               /* user_data */) CL_API_SUFFIX__VERSION_1_0;\n            clBuildProgram: [\"int\", [types.Program, \"uint\", types.DeviceIdArray, \"string\", types.BuildProgramNotify, \"pointer\"]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetProgramInfo(cl_program         /* program */,\n            //                 cl_program_info    /* param_name */,\n            //                 size_t             /* param_value_size */,\n            //                 void *             /* param_value */,\n            //                 size_t *           /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetProgramInfo: [\"int\", [types.Program, types.ProgramInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetProgramBuildInfo(cl_program            /* program */,\n            //                      cl_device_id          /* device */,\n            //                      cl_program_build_info /* param_name */,\n            //                      size_t                /* param_value_size */,\n            //                      void *                /* param_value */,\n            //                      size_t *              /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetProgramBuildInfo: [\"int\", [types.Program, types.DeviceId, types.ProgramBuildInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Kernel Object APIs */\n            //extern CL_API_ENTRY cl_kernel CL_API_CALL\n            //clCreateKernel(cl_program      /* program */,\n            //               const char *    /* kernel_name */,\n            //               cl_int *        /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateKernel: [types.Kernel, [types.Program, \"string\", ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clCreateKernelsInProgram(cl_program     /* program */,\n            //                         cl_uint        /* num_kernels */,\n            //                         cl_kernel *    /* kernels */,\n            //                         cl_uint *      /* num_kernels_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clCreateKernelsInProgram: [\"int\", [types.Program, \"uint\", types.KernelArray, ref.refType(\"uint\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainKernel(cl_kernel    /* kernel */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainKernel: [\"int\", [types.Kernel]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseKernel(cl_kernel   /* kernel */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseKernel: [\"int\", [types.Kernel]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clSetKernelArg(cl_kernel    /* kernel */,\n            //               cl_uint      /* arg_index */,\n            //               size_t       /* arg_size */,\n            //               const void * /* arg_value */) CL_API_SUFFIX__VERSION_1_0;\n            clSetKernelArg: [\"int\", [types.Kernel, \"uint\", \"size_t\", \"pointer\"]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetKernelInfo(cl_kernel       /* kernel */,\n            //                cl_kernel_info  /* param_name */,\n            //                size_t          /* param_value_size */,\n            //                void *          /* param_value */,\n            //                size_t *        /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetKernelInfo: [\"int\", [types.Kernel, types.KernelInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetKernelWorkGroupInfo(cl_kernel                  /* kernel */,\n            //                         cl_device_id               /* device */,\n            //                         cl_kernel_work_group_info  /* param_name */,\n            //                         size_t                     /* param_value_size */,\n            //                         void *                     /* param_value */,\n            //                         size_t *                   /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetKernelWorkGroupInfo: [\"int\", [types.Kernel, types.DeviceId, types.KernelWorkGroupInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Event Object APIs */\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clWaitForEvents(cl_uint             /* num_events */,\n            //                const cl_event *    /* event_list */) CL_API_SUFFIX__VERSION_1_0;\n            clWaitForEvents: [\"int\", [\"uint\", types.EventArray]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetEventInfo(cl_event         /* event */,\n            //               cl_event_info    /* param_name */,\n            //               size_t           /* param_value_size */,\n            //               void *           /* param_value */,\n            //               size_t *         /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clGetEventInfo: [\"int\", [types.Event, types.EventInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clRetainEvent(cl_event /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clRetainEvent: [\"int\", [types.Event]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseEvent(cl_event /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clReleaseEvent: [\"int\", [types.Event]],\n\n            /* Profiling APIs */\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clGetEventProfilingInfo(cl_event            /* event */,\n            //                        cl_profiling_info   /* param_name */,\n            //                        size_t              /* param_value_size */,\n            //                        void *              /* param_value */,\n            //                        size_t *            /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_0;\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clReleaseEvent(cl_event /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clGetEventProfilingInfo: [\"int\", [types.Event, types.ProfilingInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n            /* Flush and Finish APIs */\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clFlush(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n            clFlush: [\"int\", [types.CommandQueue]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clFinish(cl_command_queue /* command_queue */) CL_API_SUFFIX__VERSION_1_0;\n            clFinish: [\"int\", [types.CommandQueue]],\n\n            /* Enqueued Commands APIs */\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueReadBuffer(cl_command_queue    /* command_queue */,\n            //                   cl_mem              /* buffer */,\n            //                    cl_bool             /* blocking_read */,\n            //                    size_t              /* offset */,\n            //                    size_t              /* size */,\n            //                    void *              /* ptr */,\n            //                    cl_uint             /* num_events_in_wait_list */,\n            //                    const cl_event *    /* event_wait_list */,\n            //                    cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueReadBuffer: [\"int\", [types.CommandQueue, types.Mem, types.Bool, \"size_t\", \"size_t\", \"pointer\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueWriteBuffer(cl_command_queue   /* command_queue */,\n            //                     cl_mem             /* buffer */,\n            //                     cl_bool            /* blocking_write */,\n            //                     size_t             /* offset */,\n            //                     size_t             /* size */,\n            //                     const void *       /* ptr */,\n            //                     cl_uint            /* num_events_in_wait_list */,\n            //                     const cl_event *   /* event_wait_list */,\n            //                     cl_event *         /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueWriteBuffer: [\"int\", [types.CommandQueue, types.Mem, types.Bool, \"size_t\", \"size_t\", \"pointer\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueCopyBuffer(cl_command_queue    /* command_queue */,\n            //                    cl_mem              /* src_buffer */,\n            //                    cl_mem              /* dst_buffer */,\n            //                    size_t              /* src_offset */,\n            //                    size_t              /* dst_offset */,\n            //                    size_t              /* size */,\n            //                    cl_uint             /* num_events_in_wait_list */,\n            //                   const cl_event *    /* event_wait_list */,\n            //                    cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueCopyBuffer: [\"int\", [types.CommandQueue, types.Mem, types.Mem, \"size_t\", \"size_t\", \"size_t\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueReadImage(cl_command_queue     /* command_queue */,\n            //                   cl_mem               /* image */,\n            //                   cl_bool              /* blocking_read */,\n            //                   const size_t *       /* origin[3] */,\n            //                   const size_t *       /* region[3] */,\n            //                   size_t               /* row_pitch */,\n            //                   size_t               /* slice_pitch */,\n            //                   void *               /* ptr */,\n            //                   cl_uint              /* num_events_in_wait_list */,\n            //                   const cl_event *     /* event_wait_list */,\n            //                   cl_event *           /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueReadImage: [\"int\", [types.CommandQueue, types.Mem, types.Bool, types.SizeTArray, types.SizeTArray, \"size_t\", \"size_t\", \"pointer\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL/\n            //clEnqueueWriteImage(cl_command_queue    /* command_queue */,\n            //                    cl_mem              /* image */,\n            //                    cl_bool             /* blocking_write */,\n            //                    const size_t *      /* origin[3] */,\n            //                    const size_t *      /* region[3] */,\n            //                    size_t              /* input_row_pitch */,\n            //                    size_t              /* input_slice_pitch */,\n            //                    const void *        /* ptr */,\n            //                    cl_uint             /* num_events_in_wait_list */,\n            //                   const cl_event *    /* event_wait_list */,\n            //                    cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueWriteImage: [\"int\", [types.CommandQueue, types.Mem, types.Bool, types.SizeTArray, types.SizeTArray, \"size_t\", \"size_t\", \"pointer\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueCopyImage(cl_command_queue     /* command_queue */,\n            //                   cl_mem               /* src_image */,\n            //                   cl_mem               /* dst_image */,\n            //                   const size_t *       /* src_origin[3] */,\n            //                   const size_t *       /* dst_origin[3] */,\n            //                   const size_t *       /* region[3] */,\n            //                   cl_uint              /* num_events_in_wait_list */,\n            //                   const cl_event *     /* event_wait_list */,\n            //                   cl_event *           /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueCopyImage: [\"int\", [types.CommandQueue, types.Mem, types.Mem, types.SizeTArray, types.SizeTArray, types.SizeTArray, \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueCopyImageToBuffer(cl_command_queue /* command_queue */,\n            //                           cl_mem           /* src_image */,\n            //                           cl_mem           /* dst_buffer */,\n            //                           const size_t *   /* src_origin[3] */,\n            //                           const size_t *   /* region[3] */,\n            //                           size_t           /* dst_offset */,\n            //                           cl_uint          /* num_events_in_wait_list */,\n            //                           const cl_event * /* event_wait_list */,\n            //                           cl_event *       /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueCopyImageToBuffer: [\"int\", [types.CommandQueue, types.Mem, types.Mem, types.SizeTArray, types.SizeTArray, \"size_t\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueCopyBufferToImage(cl_command_queue /* command_queue */,\n            //                           cl_mem           /* src_buffer */,\n            //                           cl_mem           /* dst_image */,\n            //                           size_t           /* src_offset */,\n            //                           const size_t *   /* dst_origin[3] */,\n            //                           const size_t *   /* region[3] */,\n            //                           cl_uint          /* num_events_in_wait_list */,\n            //                           const cl_event * /* event_wait_list */,\n            //                           cl_event *       /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueCopyBufferToImage: [\"int\", [types.CommandQueue, types.Mem, types.Mem, \"size_t\", types.SizeTArray, types.SizeTArray, \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY void * CL_API_CALL\n            //clEnqueueMapBuffer(cl_command_queue /* command_queue */,\n            //                   cl_mem           /* buffer */,\n            //                   cl_bool          /* blocking_map */,\n            //                   cl_map_flags     /* map_flags */,\n            //                   size_t           /* offset */,\n            //                   size_t           /* size */,\n            //                   cl_uint          /* num_events_in_wait_list */,\n            //                   const cl_event * /* event_wait_list */,\n            //                   cl_event *       /* event */,\n            //                   cl_int *         /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueMapBuffer: [\"pointer\", [types.CommandQueue, types.Mem, types.Bool, types.MapFlags, \"size_t\", \"size_t\", \"uint\", types.EventArray, types.EventRef, ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY void * CL_API_CALL\n            //clEnqueueMapImage(cl_command_queue  /* command_queue */,\n            //                  cl_mem            /* image */,\n            //                  cl_bool           /* blocking_map */,\n            //                  cl_map_flags      /* map_flags */,\n            //                  const size_t *    /* origin[3] */,\n            //                  const size_t *    /* region[3] */,\n            //                  size_t *          /* image_row_pitch */,\n            //                  size_t *          /* image_slice_pitch */,\n            //                  cl_uint           /* num_events_in_wait_list */,\n            //                  const cl_event *  /* event_wait_list */,\n            //                  cl_event *        /* event */,\n            //                  cl_int *          /* errcode_ret */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueMapImage: [\"pointer\", [types.CommandQueue, types.Mem, types.Bool, types.MapFlags, types.SizeTArray, types.SizeTArray, ref.refType(\"size_t\"), ref.refType(\"size_t\"), \"uint\", types.EventArray, types.EventRef, ref.refType(\"int\")]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueUnmapMemObject(cl_command_queue /* command_queue */,\n            //                        cl_mem           /* memobj */,\n            //                        void *           /* mapped_ptr */,\n            //                        cl_uint          /* num_events_in_wait_list */,\n            //                        const cl_event *  /* event_wait_list */,\n            //                        cl_event *        /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueUnmapMemObject: [\"int\", [types.CommandQueue, types.Mem, \"pointer\", \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueNDRangeKernel(cl_command_queue /* command_queue */,\n            //                       cl_kernel        /* kernel */,\n            //                       cl_uint          /* work_dim */,\n            //                       const size_t *   /* global_work_offset */,\n            //                       const size_t *   /* global_work_size */,\n            //                       const size_t *   /* local_work_size */,\n            //                       cl_uint          /* num_events_in_wait_list */,\n            //                       const cl_event * /* event_wait_list */,\n            //                       cl_event *       /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueNDRangeKernel: [\"int\", [types.CommandQueue, types.Kernel, \"uint\", types.SizeTArray, types.SizeTArray, types.SizeTArray, \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueTask(cl_command_queue  /* command_queue */,\n            //              cl_kernel         /* kernel */,\n            //              cl_uint           /* num_events_in_wait_list */,\n            //              const cl_event *  /* event_wait_list */,\n            //              cl_event *        /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueTask: [\"int\", [types.CommandQueue, types.Kernel, \"uint\", types.EventArray, types.EventRef]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueNativeKernel(cl_command_queue  /* command_queue */,\n            //\t\t\t\t\t  void (CL_CALLBACK * /*user_func*/)(void *),\n            //                      void *            /* args */,\n            //                      size_t            /* cb_args */,\n            //                      cl_uint           /* num_mem_objects */,\n            //                      const cl_mem *    /* mem_list */,\n            //                      const void **     /* args_mem_loc */,\n            //                      cl_uint           /* num_events_in_wait_list */,\n            //                      const cl_event *  /* event_wait_list */,\n            //                      cl_event *        /* event */) CL_API_SUFFIX__VERSION_1_0;\n            clEnqueueNativeKernel: [\"int\", [types.CommandQueue, types.EnqueueNativeKernelUserFunc, \"pointer\", \"size_t\", \"uint\", types.MemArray, ref.refType(\"pointer\"), \"uint\", types.EventArray, types.EventRef]],\n\n            /*1.1*/\n            //extern CL_API_ENTRY cl_mem CL_API_CALL\n            //clCreateSubBuffer(cl_mem                   /* buffer */,\n            //                  cl_mem_flags             /* flags */,\n            //                  cl_buffer_create_type    /* buffer_create_type */,\n            //                  const void *             /* buffer_create_info */,\n            //                  cl_int *                 /* errcode_ret */) CL_API_SUFFIX__VERSION_1_1;\n            clCreateSubBuffer: [types.Mem, [types.Mem, types.MemFlags, types.BufferCreateType, \"pointer\", types.ErrorCodeRet]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clSetMemObjectDestructorCallback(  cl_mem /* memobj */,\n            //                                    void (CL_CALLBACK * /*pfn_notify*/)( cl_mem /* memobj */, void* /*user_data*/),\n            //                                    void * /*user_data */ )             CL_API_SUFFIX__VERSION_1_1;\n            clSetMemObjectDestructorCallback: [\"int\", [types.Mem, types.SetEventCallbackCallback, \"pointer\"]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clSetUserEventStatus(cl_event   /* event */,\n            //                    cl_int     /* execution_status */) CL_API_SUFFIX__VERSION_1_1;\n            clSetUserEventStatus: [\"int\", [types.Event, \"int\"]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clSetEventCallback( cl_event    /* event */,\n            //                    cl_int      /* command_exec_callback_type */,\n            //                    void (CL_CALLBACK * /* pfn_notify */)(cl_event, cl_int, void *),\n            //                    void *      /* user_data */) CL_API_SUFFIX__VERSION_1_1;\n            clSetEventCallback: [\"int\", [types.Event, \"int\", types.SetEventCallbackCallback, \"pointer\"]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueReadBufferRect(cl_command_queue    /* command_queue */,\n            //                        cl_mem              /* buffer */,\n            //                        cl_bool             /* blocking_read */,\n            //                        const size_t *      /* buffer_offset */,\n            //                        const size_t *      /* host_offset */,\n            //                        const size_t *      /* region */,\n            //                        size_t              /* buffer_row_pitch */,\n            //                        size_t              /* buffer_slice_pitch */,\n            //                        size_t              /* host_row_pitch */,\n            //                        size_t              /* host_slice_pitch */,\n            //                        void *              /* ptr */,\n            //                        cl_uint             /* num_events_in_wait_list */,\n            //                        const cl_event *    /* event_wait_list */,\n            //                        cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_1;\n            clEnqueueReadBufferRect: [\n                \"int\",\n                [\n                    types.CommandQueue,\n                    types.Mem,\n                    types.Bool,\n                    ref.refType(\"size_t\"),\n                    ref.refType(\"size_t\"),\n                    ref.refType(\"size_t\"),\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"pointer\",\n                    \"uint\",\n                    types.EventArray,\n                    types.EventRef\n                ]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueWriteBufferRect(cl_command_queue    /* command_queue */,\n            //                         cl_mem              /* buffer */,\n            //                         cl_bool             /* blocking_write */,\n            //                         const size_t *      /* buffer_offset */,\n            //                         const size_t *      /* host_offset */,\n            //                         const size_t *      /* region */,\n            //                         size_t              /* buffer_row_pitch */,\n            //                         size_t              /* buffer_slice_pitch */,\n            //                         size_t              /* host_row_pitch */,\n            //                         size_t              /* host_slice_pitch */,\n            //                         const void *        /* ptr */,\n            //                         cl_uint             /* num_events_in_wait_list */,\n            //                         const cl_event *    /* event_wait_list */,\n            //                         cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_1;\n            clEnqueueWriteBufferRect: [\n                \"int\",\n                [\n                    types.CommandQueue,\n                    types.Mem,\n                    types.Bool,\n                    ref.refType(\"size_t\"),\n                    ref.refType(\"size_t\"),\n                    ref.refType(\"size_t\"),\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"pointer\",\n                    \"uint\",\n                    types.EventArray,\n                    types.EventRef\n                ]],\n\n            //extern CL_API_ENTRY cl_int CL_API_CALL\n            //clEnqueueCopyBufferRect(cl_command_queue    /* command_queue */,\n            //                        cl_mem              /* src_buffer */,\n            //                        cl_mem              /* dst_buffer */,\n            //                        const size_t *      /* src_origin */,\n            //                        const size_t *      /* dst_origin */,\n            //                        const size_t *      /* region */,\n            //                        size_t              /* src_row_pitch */,\n            //                        size_t              /* src_slice_pitch */,\n            //                        size_t              /* dst_row_pitch */,\n            //                        size_t              /* dst_slice_pitch */,\n            //                        cl_uint             /* num_events_in_wait_list */,\n            //                        const cl_event *    /* event_wait_list */,\n            //                        cl_event *          /* event */) CL_API_SUFFIX__VERSION_1_1;\n            clEnqueueCopyBufferRect: [\n                \"int\",\n                [\n                    types.CommandQueue,\n                    types.Mem,\n                    types.Mem,\n                    types.Bool,\n                    ref.refType(\"size_t\"),\n                    ref.refType(\"size_t\"),\n                    ref.refType(\"size_t\"),\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"uint\",\n                    types.EventArray,\n                    types.EventRef\n                ]],\n\n            //extern CL_API_ENTRY cl_event CL_API_CALL\n            //clCreateUserEvent(cl_context    /* context */,\n            //                 cl_int *      /* errcode_ret */) CL_API_SUFFIX__VERSION_1_1;\n            clCreateUserEvent: [types.Event, [types.Context, ref.refType(\"int\")]],\n\n            /*\n             cl_int clGetGLObjectInfo (\tcl_mem memobj,\n                 cl_gl_object_type *gl_object_type,\n                 GLuint *gl_object_name)\n             */\n            clGetGLObjectInfo: [\"int\", [ref.refType(\"uint\"), ref.refType(\"uint\")]],\n\n            /*\n            cl_int clEnqueueWaitForEvents (\n                cl_command_queue command_queue,\n                cl_uint num_events,\n                const cl_event *event_list)\n            */\n            clEnqueueWaitForEvents: [\"int\", [types.CommandQueue, \"uint\", types.EventArray]],\n\n            /*\n             cl_int clEnqueueMarker (\n                cl_command_queue command_queue,\n                cl_event *event)\n             */\n            clEnqueueMarker: [\"int\", [types.CommandQueue, types.EventRef]],\n\n            /*\n             cl_int clEnqueueBarrier (\n             cl_command_queue command_queue,\n             cl_event *event)\n             */\n            clEnqueueBarrier: [\"int\", [types.CommandQueue, types.EventRef]],\n\n            /*\n             cl_mem clCreateImage2D (\n                 cl_context context,\n                 cl_mem_flags flags,\n                 const cl_image_format *image_format,\n                 size_t image_width,\n                 size_t image_height,\n                 size_t image_row_pitch,\n                 void *host_ptr,\n                 cl_int *errcode_ret)\n             */\n            clCreateImage2D: [types.Mem,\n                [\n                    types.Context,\n                    types.MemFlags,\n                    types.ImageFormatRef,\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"pointer\",\n                    types.ErrorCodeRet\n                ]\n            ],\n\n            /*\n             cl_mem clCreateImage3D (\n                 cl_context context,\n                 cl_mem_flags flags,\n                 const cl_image_format *image_format,\n                 size_t image_width,\n                 size_t image_height,\n                 size_t image_depth,\n                 size_t image_row_pitch,\n                 size_t image_slice_pitch,\n                 void *host_ptr,\n                 cl_int *errcode_ret)\n             */\n            clCreateImage3D: [types.Mem,\n                [\n                    types.Context,\n                    types.MemFlags,\n                    types.ImageFormatRef,\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"size_t\",\n                    \"pointer\",\n                    types.ErrorCodeRet\n                ]\n            ]\n        });\n}\n\nCL11.types = types;\n\nCL11.defs = defs;\n\nCL11.prototype.checkError = function (err) {\n    if (err) {\n        if (_.isFunction(err.deref)) {\n            err = err.deref();\n        }\n        if (err < 0) {\n            throw new CLError(err);\n        }\n    }\n};\n\nmodule.exports = CL11;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/types.js":"/*\n License: [MIT](../LICENSE)\n\n Copyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n */\n\n/*\n # types object\n\n Required ref types for communicating with the OpenCL C API.\n\n **base:** Object\n */\n\n\"use strict\";\n\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar ffi = fastcall.ffi;\nvar StructType = fastcall.StructType;\nvar ArrayType = fastcall.ArrayType;\n\nvar ImageFormat = new StructType({\n    imageChannelOrder: \"uint\",\n    imageChannelDataType: \"uint\"\n});\n\nvar ImageDesc = new StructType({\n    // _imageType_\n    // - CL_MEM_OBJECT_BUFFER\n    // - CL_MEM_OBJECT_IMAGE2D\n    // - CL_MEM_OBJECT_IMAGE3D\n    imageType: \"uint\",\n    imageWidth: \"size_t\",\n    imageHeight: \"size_t\",\n    imageDepth: \"size_t\",\n    imageArraySize: \"size_t\",\n    imageRowPitch: \"size_t\",\n    imageSlicePitch: \"size_t\",\n    numMipLevels: \"uint\",\n    numSamples: \"uint\",\n    buffer: ref.refType(\"void\")\n});\n\nvar BufferRegion = new StructType({\n    origin: \"size_t\",\n    size: \"size_t\"\n});\n\nvar types = {\n    ImageFormat: ImageFormat,\n    ImageFormatArray: new ArrayType(ImageFormat),\n    ImageFormatRef: ref.refType(ImageFormat),\n    ImageDesc: ImageDesc,\n    ImageDescRef: ref.refType(ImageDesc),\n    BufferRegion: BufferRegion,\n    Bool: ref.types.uint,\n    SizeTArray: new ArrayType(\"size_t\"),\n    StringArray: new ArrayType(\"string\"),\n    ErrorCode: ref.types.int,\n    ErrorCodeRet: ref.refType(\"int\"),\n    Bitfield: ref.types.uint64,\n    DeviceType: ref.types.uint64,\n    PlatformInfo: ref.types.uint,\n    DeviceInfo: ref.types.uint,\n    DeviceFpConfig: ref.types.uint64,\n    DeviceMemCacheType: ref.types.uint,\n    DeviceLocalMemType: ref.types.uint,\n    DeviceExecCapabilities: ref.types.uint64,\n    CommandQueueProperties: ref.types.uint64,\n    DevicePartitionProperties: new ArrayType(\"int\"),\n    DeviceAffinityDomain: ref.types.uint64,\n    ContextProperties: new ArrayType(\"size_t\"),\n    ContextInfo: ref.types.uint,\n    CommandQueueInfo: ref.types.uint,\n    ChannelOrder: ref.types.uint,\n    ChannelType: ref.types.uint,\n    MemFlags: ref.types.uint64,\n    MemObjectType: ref.types.uint,\n    MemInfo: ref.types.uint,\n    MemMigrationFlags: ref.types.uint64,\n    ImageInfo: ref.types.uint,\n    BufferCreateType: ref.types.uint,\n    AddressingMode: ref.types.uint,\n    FilterMode: ref.types.uint,\n    SamplerInfo: ref.types.uint,\n    MapFlags: ref.types.uint64,\n    ProgramInfo: ref.types.uint,\n    ProgramBuildInfo: ref.types.uint,\n    ProgramBinaryType: ref.types.uint,\n    BuildStatus: ref.types.int,\n    KernelInfo: ref.types.uint,\n    KernelArgInfo: ref.types.uint,\n    KernelArgAddressQualifier: ref.types.uint,\n    KernelArgAccessQualifier: ref.types.uint,\n    KernelArgTypeQualifier: ref.types.uint64,\n    KernelWorkGroupInfo: ref.types.uint,\n    EventInfo: ref.types.uint,\n    CommandType: ref.types.uint,\n    CommandExecutionStatus: ref.types.uint,\n    ProfilingInfo: ref.types.uint,\n    Mem: ref.refType(\"void\"),\n    MemArray: new ArrayType(ref.refType(\"void\")),\n    PlatformId: ref.refType(\"void\"),\n    PlatformIdArray: new ArrayType(ref.refType(\"void\")),\n    DeviceId: ref.refType(\"void\"),\n    DeviceIdArray: new ArrayType(ref.refType(\"void\")),\n    CommandQueue: ref.refType(\"void\"),\n    Context: ref.refType(\"void\"),\n    Sampler: ref.refType(\"void\"),\n    Program: ref.refType(\"void\"),\n    ProgramArray: new ArrayType(ref.refType(\"void\")),\n    Kernel: ref.refType(\"void\"),\n    KernelArray: new ArrayType(ref.refType(\"void\")),\n    Event: ref.refType(\"void\"),\n    EventRef: ref.refType(ref.refType(\"void\")),\n    EventArray: new ArrayType(ref.refType(\"void\")),\n    Binary: new ArrayType(\"byte\"),\n    Binaries: new ArrayType(ref.refType(\"void\")),\n    CreateContextNotify: ffi.Function(\"void\", [ \"pointer\", \"pointer\" ]),\n    BuildProgramNotify: ffi.Function(\"void\", [ \"pointer\", \"pointer\" ]),\n    EnqueueNativeKernelUserFunc: ffi.Function(\"void\", [ \"pointer\" ]),\n    SetEventCallbackCallback: ffi.Function(\"void\", [ \"pointer\", \"int\", \"pointer\" ]),\n    MemObjectDestructorCallback: ffi.Function(\"void\", [ \"pointer\", \"pointer\" ])\n};\n\nmodule.exports = types;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clDefines.js":"/*\r\nLicense: [MIT](../LICENSE)\r\n\r\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\r\n*/\r\n\r\n/*\r\n# clDefines object\r\n\r\nDefined constants of the OpenCL SDK.\r\n\r\n**base:** Object\r\n*/\r\n\r\n\"use strict\";\r\n\r\nvar clDefines = {\r\n    /* ###Errors */\r\n    CL_SUCCESS: 0,\r\n    CL_DEVICE_NOT_FOUND: -1,\r\n    CL_DEVICE_NOT_AVAILABLE: -2,\r\n    CL_COMPILER_NOT_AVAILABLE: -3,\r\n    CL_MEM_OBJECT_ALLOCATION_FAILURE: -4,\r\n    CL_OUT_OF_RESOURCES: -5,\r\n    CL_OUT_OF_HOST_MEMORY: -6,\r\n    CL_PROFILING_INFO_NOT_AVAILABLE: -7,\r\n    CL_MEM_COPY_OVERLAP: -8,\r\n    CL_IMAGE_FORMAT_MISMATCH: -9,\r\n    CL_IMAGE_FORMAT_NOT_SUPPORTED: -10,\r\n    CL_BUILD_PROGRAM_FAILURE: -11,\r\n    CL_MAP_FAILURE: -12,\r\n    CL_MISALIGNED_SUB_BUFFER_OFFSET: -13,\r\n    CL_EXEC_STATUS_ERROR_FOR_EVENTS_IN_WAIT_LIST: -14,\r\n    CL_COMPILE_PROGRAM_FAILURE: -15,\r\n    CL_LINKER_NOT_AVAILABLE: -16,\r\n    CL_LINK_PROGRAM_FAILURE: -17,\r\n    CL_DEVICE_PARTITION_FAILED: -18,\r\n    CL_KERNEL_ARG_INFO_NOT_AVAILABLE: -19,\r\n    CL_INVALID_VALUE: -30,\r\n    CL_INVALID_DEVICE_TYPE: -31,\r\n    CL_INVALID_PLATFORM: -32,\r\n    CL_INVALID_DEVICE: -33,\r\n    CL_INVALID_CONTEXT: -34,\r\n    CL_INVALID_QUEUE_PROPERTIES: -35,\r\n    CL_INVALID_COMMAND_QUEUE: -36,\r\n    CL_INVALID_HOST_PTR: -37,\r\n    CL_INVALID_MEM_OBJECT: -38,\r\n    CL_INVALID_IMAGE_FORMAT_DESCRIPTOR: -39,\r\n    CL_INVALID_IMAGE_SIZE: -40,\r\n    CL_INVALID_SAMPLER: -41,\r\n    CL_INVALID_BINARY: -42,\r\n    CL_INVALID_BUILD_OPTIONS: -43,\r\n    CL_INVALID_PROGRAM: -44,\r\n    CL_INVALID_PROGRAM_EXECUTABLE: -45,\r\n    CL_INVALID_KERNEL_NAME: -46,\r\n    CL_INVALID_KERNEL_DEFINITION: -47,\r\n    CL_INVALID_KERNEL: -48,\r\n    CL_INVALID_ARG_INDEX: -49,\r\n    CL_INVALID_ARG_VALUE: -50,\r\n    CL_INVALID_ARG_SIZE: -51,\r\n    CL_INVALID_KERNEL_ARGS: -52,\r\n    CL_INVALID_WORK_DIMENSION: -53,\r\n    CL_INVALID_WORK_GROUP_SIZE: -54,\r\n    CL_INVALID_WORK_ITEM_SIZE: -55,\r\n    CL_INVALID_GLOBAL_OFFSET: -56,\r\n    CL_INVALID_EVENT_WAIT_LIST: -57,\r\n    CL_INVALID_EVENT: -58,\r\n    CL_INVALID_OPERATION: -59,\r\n    CL_INVALID_GL_OBJECT: -60,\r\n    CL_INVALID_BUFFER_SIZE: -61,\r\n    CL_INVALID_MIP_LEVEL: -62,\r\n    CL_INVALID_GLOBAL_WORK_SIZE: -63,\r\n    CL_INVALID_PROPERTY: -64,\r\n    CL_INVALID_IMAGE_DESCRIPTOR: -65,\r\n    CL_INVALID_COMPILER_OPTIONS: -66,\r\n    CL_INVALID_LINKER_OPTIONS: -67,\r\n    CL_INVALID_DEVICE_PARTITION_COUNT: -68,\r\n    /* ###OpenCL Version */\r\n    CL_VERSION_1_0: 1,\r\n    CL_VERSION_1_1: 1,\r\n    CL_VERSION_1_2: 1,\r\n    /* ###cl_bool */\r\n    CL_FALSE: 0,\r\n    CL_TRUE: 1,\r\n    CL_BLOCKING: 1,\r\n    CL_NON_BLOCKING: 0,\r\n    /* ###cl_platform_info */\r\n    CL_PLATFORM_PROFILE: 0x0900,\r\n    CL_PLATFORM_VERSION: 0x0901,\r\n    CL_PLATFORM_NAME: 0x0902,\r\n    CL_PLATFORM_VENDOR: 0x0903,\r\n    CL_PLATFORM_EXTENSIONS: 0x0904,\r\n    /* ### cl_device_type - Bitfield */\r\n    CL_DEVICE_TYPE_DEFAULT: (1 << 0),\r\n    CL_DEVICE_TYPE_CPU: (1 << 1),\r\n    CL_DEVICE_TYPE_GPU: (1 << 2),\r\n    CL_DEVICE_TYPE_ACCELERATOR: (1 << 3),\r\n    CL_DEVICE_TYPE_CUSTOM: (1 << 4),\r\n    CL_DEVICE_TYPE_ALL: 0xFFFFFFFF,\r\n    /* ### cl_device_info */\r\n    CL_DEVICE_TYPE: 0x1000,\r\n    CL_DEVICE_VENDOR_ID: 0x1001,\r\n    CL_DEVICE_MAX_COMPUTE_UNITS: 0x1002,\r\n    CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS: 0x1003,\r\n    CL_DEVICE_MAX_WORK_GROUP_SIZE: 0x1004,\r\n    CL_DEVICE_MAX_WORK_ITEM_SIZES: 0x1005,\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_CHAR: 0x1006,\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_SHORT: 0x1007,\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_INT: 0x1008,\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_LONG: 0x1009,\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_FLOAT: 0x100A,\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_DOUBLE: 0x100B,\r\n    CL_DEVICE_MAX_CLOCK_FREQUENCY: 0x100C,\r\n    CL_DEVICE_ADDRESS_BITS: 0x100D,\r\n    CL_DEVICE_MAX_READ_IMAGE_ARGS: 0x100E,\r\n    CL_DEVICE_MAX_WRITE_IMAGE_ARGS: 0x100F,\r\n    CL_DEVICE_MAX_MEM_ALLOC_SIZE: 0x1010,\r\n    CL_DEVICE_IMAGE2D_MAX_WIDTH: 0x1011,\r\n    CL_DEVICE_IMAGE2D_MAX_HEIGHT: 0x1012,\r\n    CL_DEVICE_IMAGE3D_MAX_WIDTH: 0x1013,\r\n    CL_DEVICE_IMAGE3D_MAX_HEIGHT: 0x1014,\r\n    CL_DEVICE_IMAGE3D_MAX_DEPTH: 0x1015,\r\n    CL_DEVICE_IMAGE_SUPPORT: 0x1016,\r\n    CL_DEVICE_MAX_PARAMETER_SIZE: 0x1017,\r\n    CL_DEVICE_MAX_SAMPLERS: 0x1018,\r\n    CL_DEVICE_MEM_BASE_ADDR_ALIGN: 0x1019,\r\n    CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE: 0x101A,\r\n    CL_DEVICE_SINGLE_FP_CONFIG: 0x101B,\r\n    CL_DEVICE_GLOBAL_MEM_CACHE_TYPE: 0x101C,\r\n    CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE: 0x101D,\r\n    CL_DEVICE_GLOBAL_MEM_CACHE_SIZE: 0x101E,\r\n    CL_DEVICE_GLOBAL_MEM_SIZE: 0x101F,\r\n    CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE: 0x1020,\r\n    CL_DEVICE_MAX_CONSTANT_ARGS: 0x1021,\r\n    CL_DEVICE_LOCAL_MEM_TYPE: 0x1022,\r\n    CL_DEVICE_LOCAL_MEM_SIZE: 0x1023,\r\n    CL_DEVICE_ERROR_CORRECTION_SUPPORT: 0x1024,\r\n    CL_DEVICE_PROFILING_TIMER_RESOLUTION: 0x1025,\r\n    CL_DEVICE_ENDIAN_LITTLE: 0x1026,\r\n    CL_DEVICE_AVAILABLE: 0x1027,\r\n    CL_DEVICE_COMPILER_AVAILABLE: 0x1028,\r\n    CL_DEVICE_EXECUTION_CAPABILITIES: 0x1029,\r\n    CL_DEVICE_QUEUE_PROPERTIES: 0x102A,\r\n    CL_DEVICE_NAME: 0x102B,\r\n    CL_DEVICE_VENDOR: 0x102C,\r\n    CL_DRIVER_VERSION: 0x102D,\r\n    CL_DEVICE_PROFILE: 0x102E,\r\n    CL_DEVICE_VERSION: 0x102F,\r\n    CL_DEVICE_EXTENSIONS: 0x1030,\r\n    CL_DEVICE_PLATFORM: 0x1031,\r\n    CL_DEVICE_DOUBLE_FP_CONFIG: 0x1032,\r\n    /* 0x1033 reserved for CL_DEVICE_HALF_FP_CONFIG */\r\n    CL_DEVICE_PREFERRED_VECTOR_WIDTH_HALF: 0x1034,\r\n    CL_DEVICE_HOST_UNIFIED_MEMORY: 0x1035,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_CHAR: 0x1036,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_SHORT: 0x1037,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_INT: 0x1038,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_LONG: 0x1039,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_FLOAT: 0x103A,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_DOUBLE: 0x103B,\r\n    CL_DEVICE_NATIVE_VECTOR_WIDTH_HALF: 0x103C,\r\n    CL_DEVICE_OPENCL_C_VERSION: 0x103D,\r\n    CL_DEVICE_LINKER_AVAILABLE: 0x103E,\r\n    CL_DEVICE_BUILT_IN_KERNELS: 0x103F,\r\n    CL_DEVICE_IMAGE_MAX_BUFFER_SIZE: 0x1040,\r\n    CL_DEVICE_IMAGE_MAX_ARRAY_SIZE: 0x1041,\r\n    CL_DEVICE_PARENT_DEVICE: 0x1042,\r\n    CL_DEVICE_PARTITION_MAX_SUB_DEVICES: 0x1043,\r\n    CL_DEVICE_PARTITION_PROPERTIES: 0x1044,\r\n    CL_DEVICE_PARTITION_AFFINITY_DOMAIN: 0x1045,\r\n    CL_DEVICE_PARTITION_TYPE: 0x1046,\r\n    CL_DEVICE_REFERENCE_COUNT: 0x1047,\r\n    CL_DEVICE_PREFERRED_INTEROP_USER_SYNC: 0x1048,\r\n    CL_DEVICE_PRINTF_BUFFER_SIZE: 0x1049,\r\n    CL_DEVICE_IMAGE_PITCH_ALIGNMENT: 0x104A,\r\n    CL_DEVICE_IMAGE_BASE_ADDRESS_ALIGNMENT: 0x104B,\r\n    /* ### cl_device_fp_config - Bitfield */\r\n    CL_FP_DENORM: (1 << 0),\r\n    CL_FP_INF_NAN: (1 << 1),\r\n    CL_FP_ROUND_TO_NEAREST: (1 << 2),\r\n    CL_FP_ROUND_TO_ZERO: (1 << 3),\r\n    CL_FP_ROUND_TO_INF: (1 << 4),\r\n    CL_FP_FMA: (1 << 5),\r\n    CL_FP_SOFT_FLOAT: (1 << 6),\r\n    CL_FP_CORRECTLY_ROUNDED_DIVIDE_SQRT: (1 << 7),\r\n    /* ### cl_device_mem_cache_type */\r\n    CL_NONE: 0x0,\r\n    CL_READ_ONLY_CACHE: 0x1,\r\n    CL_READ_WRITE_CACHE: 0x2,\r\n    /* ### cl_device_local_mem_type */\r\n    CL_LOCAL: 0x1,\r\n    CL_GLOBAL: 0x2,\r\n    /* ### cl_device_exec_capabilities - Bitfield */\r\n    CL_EXEC_KERNEL: (1 << 0),\r\n    CL_EXEC_NATIVE_KERNEL: (1 << 1),\r\n    /* ### cl_command_queue_properties - Bitfield */\r\n    CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE: (1 << 0),\r\n    CL_QUEUE_PROFILING_ENABLE: (1 << 1),\r\n    /* ### cl_context_info  */\r\n    CL_CONTEXT_REFERENCE_COUNT: 0x1080,\r\n    CL_CONTEXT_DEVICES: 0x1081,\r\n    CL_CONTEXT_PROPERTIES: 0x1082,\r\n    CL_CONTEXT_NUM_DEVICES: 0x1083,\r\n    /* ### cl_context_properties */\r\n    CL_CONTEXT_PLATFORM: 0x1084,\r\n    CL_CONTEXT_INTEROP_USER_SYNC: 0x1085,\r\n    /* ### cl_device_partition_property */\r\n    CL_DEVICE_PARTITION_EQUALLY: 0x1086,\r\n    CL_DEVICE_PARTITION_BY_COUNTS: 0x1087,\r\n    CL_DEVICE_PARTITION_BY_COUNTS_LIST_END: 0x0,\r\n    CL_DEVICE_PARTITION_BY_AFFINITY_DOMAIN: 0x1088,\r\n    /* ### cl_device_affinity_domain */\r\n    CL_DEVICE_AFFINITY_DOMAIN_NUMA: (1 << 0),\r\n    CL_DEVICE_AFFINITY_DOMAIN_L4_CACHE: (1 << 1),\r\n    CL_DEVICE_AFFINITY_DOMAIN_L3_CACHE: (1 << 2),\r\n    CL_DEVICE_AFFINITY_DOMAIN_L2_CACHE: (1 << 3),\r\n    CL_DEVICE_AFFINITY_DOMAIN_L1_CACHE: (1 << 4),\r\n    CL_DEVICE_AFFINITY_DOMAIN_NEXT_PARTITIONABLE: (1 << 5),\r\n    /* ### cl_command_queue_info */\r\n    CL_QUEUE_CONTEXT: 0x1090,\r\n    CL_QUEUE_DEVICE: 0x1091,\r\n    CL_QUEUE_REFERENCE_COUNT: 0x1092,\r\n    CL_QUEUE_PROPERTIES: 0x1093,\r\n    /* ### cl_mem_flags - Bitfield */\r\n    CL_MEM_READ_WRITE: (1 << 0),\r\n    CL_MEM_WRITE_ONLY: (1 << 1),\r\n    CL_MEM_READ_ONLY: (1 << 2),\r\n    CL_MEM_USE_HOST_PTR: (1 << 3),\r\n    CL_MEM_ALLOC_HOST_PTR: (1 << 4),\r\n    CL_MEM_COPY_HOST_PTR: (1 << 5),\r\n    CL_MEM_HOST_WRITE_ONLY: (1 << 7),\r\n    CL_MEM_HOST_READ_ONLY: (1 << 8),\r\n    CL_MEM_HOST_NO_ACCESS: (1 << 9),\r\n    /* ### cl_mem_migration_flags - Bitfield */\r\n    CL_MIGRATE_MEM_OBJECT_HOST: (1 << 0),\r\n    CL_MIGRATE_MEM_OBJECT_CONTENT_UNDEFINED: (1 << 1),\r\n    /* ### cl_channel_order */\r\n    CL_R: 0x10B0,\r\n    CL_A: 0x10B1,\r\n    CL_RG: 0x10B2,\r\n    CL_RA: 0x10B3,\r\n    CL_RGB: 0x10B4,\r\n    CL_RGBA: 0x10B5,\r\n    CL_BGRA: 0x10B6,\r\n    CL_ARGB: 0x10B7,\r\n    CL_INTENSITY: 0x10B8,\r\n    CL_LUMINANCE: 0x10B9,\r\n    CL_Rx: 0x10BA,\r\n    CL_RGx: 0x10BB,\r\n    CL_RGBx: 0x10BC,\r\n    CL_DEPTH: 0x10BD,\r\n    CL_DEPTH_STENCIL: 0x10BE,\r\n    /* ### cl_channel_type */\r\n    CL_SNORM_INT8: 0x10D0,\r\n    CL_SNORM_INT16: 0x10D1,\r\n    CL_UNORM_INT8: 0x10D2,\r\n    CL_UNORM_INT16: 0x10D3,\r\n    CL_UNORM_SHORT_565: 0x10D4,\r\n    CL_UNORM_SHORT_555: 0x10D5,\r\n    CL_UNORM_INT_101010: 0x10D6,\r\n    CL_SIGNED_INT8: 0x10D7,\r\n    CL_SIGNED_INT16: 0x10D8,\r\n    CL_SIGNED_INT32: 0x10D9,\r\n    CL_UNSIGNED_INT8: 0x10DA,\r\n    CL_UNSIGNED_INT16: 0x10DB,\r\n    CL_UNSIGNED_INT32: 0x10DC,\r\n    CL_HALF_FLOAT: 0x10DD,\r\n    CL_FLOAT: 0x10DE,\r\n    CL_UNORM_INT24: 0x10DF,\r\n    /* ### cl_mem_object_type */\r\n    CL_MEM_OBJECT_BUFFER: 0x10F0,\r\n    CL_MEM_OBJECT_IMAGE2D: 0x10F1,\r\n    CL_MEM_OBJECT_IMAGE3D: 0x10F2,\r\n    CL_MEM_OBJECT_IMAGE2D_ARRAY: 0x10F3,\r\n    CL_MEM_OBJECT_IMAGE1D: 0x10F4,\r\n    CL_MEM_OBJECT_IMAGE1D_ARRAY: 0x10F5,\r\n    CL_MEM_OBJECT_IMAGE1D_BUFFER: 0x10F6,\r\n    /* ### cl_mem_info */\r\n    CL_MEM_TYPE: 0x1100,\r\n    CL_MEM_FLAGS: 0x1101,\r\n    CL_MEM_SIZE: 0x1102,\r\n    CL_MEM_HOST_PTR: 0x1103,\r\n    CL_MEM_MAP_COUNT: 0x1104,\r\n    CL_MEM_REFERENCE_COUNT: 0x1105,\r\n    CL_MEM_CONTEXT: 0x1106,\r\n    CL_MEM_ASSOCIATED_MEMOBJECT: 0x1107,\r\n    CL_MEM_OFFSET: 0x1108,\r\n    /* ### cl_image_info */\r\n    CL_IMAGE_FORMAT: 0x1110,\r\n    CL_IMAGE_ELEMENT_SIZE: 0x1111,\r\n    CL_IMAGE_ROW_PITCH: 0x1112,\r\n    CL_IMAGE_SLICE_PITCH: 0x1113,\r\n    CL_IMAGE_WIDTH: 0x1114,\r\n    CL_IMAGE_HEIGHT: 0x1115,\r\n    CL_IMAGE_DEPTH: 0x1116,\r\n    CL_IMAGE_ARRAY_SIZE: 0x1117,\r\n    CL_IMAGE_BUFFER: 0x1118,\r\n    CL_IMAGE_NUM_MIP_LEVELS: 0x1119,\r\n    CL_IMAGE_NUM_SAMPLES: 0x111A,\r\n    /* ### cl_addressing_mode */\r\n    CL_ADDRESS_NONE: 0x1130,\r\n    CL_ADDRESS_CLAMP_TO_EDGE: 0x1131,\r\n    CL_ADDRESS_CLAMP: 0x1132,\r\n    CL_ADDRESS_REPEAT: 0x1133,\r\n    CL_ADDRESS_MIRRORED_REPEAT: 0x1134,\r\n    /* ### cl_filter_mode */\r\n    CL_FILTER_NEAREST: 0x1140,\r\n    CL_FILTER_LINEAR: 0x1141,\r\n    /* ### cl_sampler_info */\r\n    CL_SAMPLER_REFERENCE_COUNT: 0x1150,\r\n    CL_SAMPLER_CONTEXT: 0x1151,\r\n    CL_SAMPLER_NORMALIZED_COORDS: 0x1152,\r\n    CL_SAMPLER_ADDRESSING_MODE: 0x1153,\r\n    CL_SAMPLER_FILTER_MODE: 0x1154,\r\n    /* ### cl_map_flags - Bitfield */\r\n    CL_MAP_READ: (1 << 0),\r\n    CL_MAP_WRITE: (1 << 1),\r\n    CL_MAP_WRITE_INVALIDATE_REGION: (1 << 2),\r\n    /* ### cl_program_info */\r\n    CL_PROGRAM_REFERENCE_COUNT: 0x1160,\r\n    CL_PROGRAM_CONTEXT: 0x1161,\r\n    CL_PROGRAM_NUM_DEVICES: 0x1162,\r\n    CL_PROGRAM_DEVICES: 0x1163,\r\n    CL_PROGRAM_SOURCE: 0x1164,\r\n    CL_PROGRAM_BINARY_SIZES: 0x1165,\r\n    CL_PROGRAM_BINARIES: 0x1166,\r\n    CL_PROGRAM_NUM_KERNELS: 0x1167,\r\n    CL_PROGRAM_KERNEL_NAMES: 0x1168,\r\n    /* ### cl_program_build_info */\r\n    CL_PROGRAM_BUILD_STATUS: 0x1181,\r\n    CL_PROGRAM_BUILD_OPTIONS: 0x1182,\r\n    CL_PROGRAM_BUILD_LOG: 0x1183,\r\n    CL_PROGRAM_BINARY_TYPE: 0x1184,\r\n    /* ### cl_program_binary_type */\r\n    CL_PROGRAM_BINARY_TYPE_NONE: 0x0,\r\n    CL_PROGRAM_BINARY_TYPE_COMPILED_OBJECT: 0x1,\r\n    CL_PROGRAM_BINARY_TYPE_LIBRARY: 0x2,\r\n    CL_PROGRAM_BINARY_TYPE_EXECUTABLE: 0x4,\r\n    /* ### cl_build_status */\r\n    CL_BUILD_SUCCESS: 0,\r\n    CL_BUILD_NONE: -1,\r\n    CL_BUILD_ERROR: -2,\r\n    CL_BUILD_IN_PROGRESS: -3,\r\n    /* ### cl_kernel_info */\r\n    CL_KERNEL_FUNCTION_NAME: 0x1190,\r\n    CL_KERNEL_NUM_ARGS: 0x1191,\r\n    CL_KERNEL_REFERENCE_COUNT: 0x1192,\r\n    CL_KERNEL_CONTEXT: 0x1193,\r\n    CL_KERNEL_PROGRAM: 0x1194,\r\n    CL_KERNEL_ATTRIBUTES: 0x1195,\r\n    /* ### cl_kernel_arg_info */\r\n    CL_KERNEL_ARG_ADDRESS_QUALIFIER: 0x1196,\r\n    CL_KERNEL_ARG_ACCESS_QUALIFIER: 0x1197,\r\n    CL_KERNEL_ARG_TYPE_NAME: 0x1198,\r\n    CL_KERNEL_ARG_TYPE_QUALIFIER: 0x1199,\r\n    CL_KERNEL_ARG_NAME: 0x119A,\r\n    /* ### cl_kernel_arg_address_qualifier */\r\n    CL_KERNEL_ARG_ADDRESS_GLOBAL: 0x119B,\r\n    CL_KERNEL_ARG_ADDRESS_LOCAL: 0x119C,\r\n    CL_KERNEL_ARG_ADDRESS_CONSTANT: 0x119D,\r\n    CL_KERNEL_ARG_ADDRESS_PRIVATE: 0x119E,\r\n    /* ### cl_kernel_arg_access_qualifier */\r\n    CL_KERNEL_ARG_ACCESS_READ_ONLY: 0x11A0,\r\n    CL_KERNEL_ARG_ACCESS_WRITE_ONLY: 0x11A1,\r\n    CL_KERNEL_ARG_ACCESS_READ_WRITE: 0x11A2,\r\n    CL_KERNEL_ARG_ACCESS_NONE: 0x11A3,\r\n    /* ### cl_kernel_arg_type_qualifer */\r\n    CL_KERNEL_ARG_TYPE_NONE: 0,\r\n    CL_KERNEL_ARG_TYPE_CONST: (1 << 0),\r\n    CL_KERNEL_ARG_TYPE_RESTRICT: (1 << 1),\r\n    CL_KERNEL_ARG_TYPE_VOLATILE: (1 << 2),\r\n    /* ### cl_kernel_work_group_info */\r\n    CL_KERNEL_WORK_GROUP_SIZE: 0x11B0,\r\n    CL_KERNEL_COMPILE_WORK_GROUP_SIZE: 0x11B1,\r\n    CL_KERNEL_LOCAL_MEM_SIZE: 0x11B2,\r\n    CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE: 0x11B3,\r\n    CL_KERNEL_PRIVATE_MEM_SIZE: 0x11B4,\r\n    CL_KERNEL_GLOBAL_WORK_SIZE: 0x11B5,\r\n    /* ### cl_event_info  */\r\n    CL_EVENT_COMMAND_QUEUE: 0x11D0,\r\n    CL_EVENT_COMMAND_TYPE: 0x11D1,\r\n    CL_EVENT_REFERENCE_COUNT: 0x11D2,\r\n    CL_EVENT_COMMAND_EXECUTION_STATUS: 0x11D3,\r\n    CL_EVENT_CONTEXT: 0x11D4,\r\n    /* ### cl_command_type */\r\n    CL_COMMAND_NDRANGE_KERNEL: 0x11F0,\r\n    CL_COMMAND_TASK: 0x11F1,\r\n    CL_COMMAND_NATIVE_KERNEL: 0x11F2,\r\n    CL_COMMAND_READ_BUFFER: 0x11F3,\r\n    CL_COMMAND_WRITE_BUFFER: 0x11F4,\r\n    CL_COMMAND_COPY_BUFFER: 0x11F5,\r\n    CL_COMMAND_READ_IMAGE: 0x11F6,\r\n    CL_COMMAND_WRITE_IMAGE: 0x11F7,\r\n    CL_COMMAND_COPY_IMAGE: 0x11F8,\r\n    CL_COMMAND_COPY_IMAGE_TO_BUFFER: 0x11F9,\r\n    CL_COMMAND_COPY_BUFFER_TO_IMAGE: 0x11FA,\r\n    CL_COMMAND_MAP_BUFFER: 0x11FB,\r\n    CL_COMMAND_MAP_IMAGE: 0x11FC,\r\n    CL_COMMAND_UNMAP_MEM_OBJECT: 0x11FD,\r\n    CL_COMMAND_MARKER: 0x11FE,\r\n    CL_COMMAND_ACQUIRE_GL_OBJECTS: 0x11FF,\r\n    CL_COMMAND_RELEASE_GL_OBJECTS: 0x1200,\r\n    CL_COMMAND_READ_BUFFER_RECT: 0x1201,\r\n    CL_COMMAND_WRITE_BUFFER_RECT: 0x1202,\r\n    CL_COMMAND_COPY_BUFFER_RECT: 0x1203,\r\n    CL_COMMAND_USER: 0x1204,\r\n    CL_COMMAND_BARRIER: 0x1205,\r\n    CL_COMMAND_MIGRATE_MEM_OBJECTS: 0x1206,\r\n    CL_COMMAND_FILL_BUFFER: 0x1207,\r\n    CL_COMMAND_FILL_IMAGE: 0x1208,\r\n    /* ### command execution status */\r\n    CL_COMPLETE: 0x0,\r\n    CL_RUNNING: 0x1,\r\n    CL_SUBMITTED: 0x2,\r\n    CL_QUEUED: 0x3,\r\n    /* ### cl_buffer_create_type  */\r\n    CL_BUFFER_CREATE_TYPE_REGION: 0x1220,\r\n    /* ### cl_profiling_info  */\r\n    CL_PROFILING_COMMAND_QUEUED: 0x1280,\r\n    CL_PROFILING_COMMAND_SUBMIT: 0x1281,\r\n    CL_PROFILING_COMMAND_START: 0x1282,\r\n    CL_PROFILING_COMMAND_END: 0x1283,\r\n\r\n    CL_DEVICE_COMPUTE_CAPABILITY_MAJOR_NV: 0x4000,\r\n    CL_DEVICE_COMPUTE_CAPABILITY_MINOR_NV: 0x4001,\r\n    CL_DEVICE_REGISTERS_PER_BLOCK_NV: 0x4002,\r\n    CL_DEVICE_WARP_SIZE_NV: 0x4003,\r\n    CL_DEVICE_GPU_OVERLAP_NV: 0x4004,\r\n    CL_DEVICE_KERNEL_EXEC_TIMEOUT_NV: 0x4005,\r\n    CL_DEVICE_INTEGRATED_MEMORY_NV: 0x4006,\r\n\r\n    CL_DEVICE_GLOBAL_FREE_MEMORY_AMD: 0x4039,\r\n    CL_DEVICE_SIMD_PER_COMPUTE_UNIT_AMD: 0x4040,\r\n    CL_DEVICE_SIMD_WIDTH_AMD: 0x4041,\r\n    CL_DEVICE_SIMD_INSTRUCTION_WIDTH_AMD: 0x4042,\r\n    CL_DEVICE_WAVEFRONT_WIDTH_AMD: 0x4043,\r\n    CL_DEVICE_GLOBAL_MEM_CHANNELS_AMD: 0x4044,\r\n    CL_DEVICE_GLOBAL_MEM_CHANNEL_BANKS_AMD: 0x4045,\r\n    CL_DEVICE_GLOBAL_MEM_CHANNEL_BANK_WIDTH_AMD: 0x4046,\r\n    CL_DEVICE_LOCAL_MEM_SIZE_PER_COMPUTE_UNIT_AMD: 0x4047,\r\n    CL_DEVICE_LOCAL_MEM_BANKS_AMD: 0x4048\r\n};\r\n\r\nmodule.exports = clDefines;\r\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clError.js":"\"use strict\";\r\n\r\nvar util = require(\"util\");\r\nvar defs = require(\"./clDefines\");\r\nvar _ = require(\"lodash\");\r\n\r\nfunction CLError(code, message) {\r\n    Error.call(this);\r\n    Error.captureStackTrace(this, CLError);\r\n    var typeKey = _.first(_.filter(_.keys(defs), function (defKey) {\r\n        return defs[defKey] === code;\r\n    }));\r\n    var type = typeKey || \"UNKNOWN\";\r\n    this.name = \"CLError\";\r\n    this.message = \"OpenCL Error Code: \" + code + \" Type: \" + type;\r\n    if (message) {\r\n        this.message += \" Message: \" + message;\r\n    }\r\n    this.code = code;\r\n    this._type = type;\r\n}\r\n\r\nutil.inherits(CLError, Error);\r\n\r\nmodule.exports = CLError;\r\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/cl12.js":"\"use strict\";\n\nvar util = require(\"util\");\nvar CL11 = require(\"./cl11\");\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar ffi = fastcall.ffi;\n\nfunction CL12() {\n    CL11.call(this);\n    var types = this.types;\n    this.version = 1.2;\n    _.extend(\n        this.imports,\n        new ffi.Library(this.libName,\n            {\n                //   extern CL_API_ENTRY cl_int CL_API_CALL/\n                //clCreateSubDevices(cl_device_id                         /* in_device */,\n                //                   const cl_device_partition_property * /* properties */,\n                //                   cl_uint                              /* num_devices */,\n                //                 cl_device_id *                       /* out_devices */,\n                //                   cl_uint *                            /* num_devices_ret */) CL_API_SUFFIX__VERSION_1_2;\n                clCreateSubDevices: [\"int\", [\"pointer\", types.DevicePartitionProperties, \"uint\", ref.refType(types.DeviceId), types.ErrorCodeRet]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clRetainDevice(cl_device_id /* device */) CL_API_SUFFIX__VERSION_1_2;\n                clRetainDevice: [\"int\", [\"pointer\"]],\n\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clReleaseDevice(cl_device_id /* device */) CL_API_SUFFIX__VERSION_1_2;\n                clReleaseDevice: [\"int\", [\"pointer\"]],\n\n                //extern CL_API_ENTRY cl_mem CL_API_CALL\n                //clCreateImage(cl_context              /* context */,\n                //              cl_mem_flags            /* flags */,\n                //              const cl_image_format * /* image_format */,\n                //              const cl_image_desc *   /* image_desc */,\n                //              void *                  /* host_ptr */,\n                //              cl_int *                /* errcode_ret */) CL_API_SUFFIX__VERSION_1_2;\n                clCreateImage: [types.Mem, [\"pointer\", types.MemFlags, types.ImageFormatRef, types.ImageDescRef, \"pointer\", types.ErrorCodeRet]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clCompileProgram(cl_program           /* program */,\n                //                 cl_uint              /* num_devices */,\n                //                 const cl_device_id * /* device_list */,\n                //                 const char *         /* options */,\n                //                 cl_uint              /* num_input_headers */,\n                //                 const cl_program *   /* input_headers */,\n                //                 const char **        /* header_include_names */,\n                //                 void (CL_CALLBACK *  /* pfn_notify */)(cl_program /* program */, void * /* user_data */),\n                //                 void *               /* user_data */) CL_API_SUFFIX__VERSION_1_2;\n                clCompileProgram: [\"int\", [types.Program, \"uint\", types.DeviceIdArray, \"string\", \"uint\", types.ProgramArray, types.StringArray, types.BuildProgramNotify, \"pointer\"]],\n\n                //extern CL_API_ENTRY cl_program CL_API_CALL/\n                //clLinkProgram(cl_context           /* context */,\n                //              cl_uint              /* num_devices */,\n                //              const cl_device_id * /* device_list */,\n                //              const char *         /* options */,\n                //              cl_uint              /* num_input_programs */,\n                //              const cl_program *   /* input_programs */,\n                //              void (CL_CALLBACK *  /* pfn_notify */)(cl_program /* program */, void * /* user_data */),\n                //              void *               /* user_data */,\n                //              cl_int *             /* errcode_ret */ ) CL_API_SUFFIX__VERSION_1_2;\n                clLinkProgram: [types.Program, [types.Context, \"uint\", types.DeviceIdArray, \"string\", \"uint\", types.ProgramArray, types.BuildProgramNotify, types.ErrorCodeRet, \"pointer\"]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clUnloadPlatformCompiler(cl_platform_id /* platform */) CL_API_SUFFIX__VERSION_1_2;\n                clUnloadPlatformCompiler: [\"int\", [types.PlatformId]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clEnqueueFillBuffer(cl_command_queue   /* command_queue */,\n                //                    cl_mem             /* buffer */,\n                //                    const void *       /* pattern */,\n                //                    size_t             /* pattern_size */,\n                //                    size_t             /* offset */,\n                //                    size_t             /* size */,\n                //                    cl_uint            /* num_events_in_wait_list */,\n                //                    const cl_event *   /* event_wait_list */,\n                //                    cl_event *         /* event */) CL_API_SUFFIX__VERSION_1_2;\n                clEnqueueFillBuffer: [\"int\", [types.CommandQueue, types.Mem, \"pointer\", \"size_t\", \"size_t\", \"size_t\", \"uint\", types.EventArray, types.EventRef]],\n\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clEnqueueFillImage(cl_command_queue   /* command_queue */,\n                //                   cl_mem             /* image */,\n                //                   const void *       /* fill_color */,\n                //                   const size_t *     /* origin[3] */,\n                //                   const size_t *     /* region[3] */,\n                //                   cl_uint            /* num_events_in_wait_list */,\n                //                   const cl_event *   /* event_wait_list */,\n                //                   cl_event *         /* event */) CL_API_SUFFIX__VERSION_1_2;\n                clEnqueueFillImage: [\"int\", [types.CommandQueue, types.Mem, \"pointer\", types.SizeTArray, types.SizeTArray, \"uint\", types.EventArray, types.EventRef]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clEnqueueMigrateMemObjects(cl_command_queue       /* command_queue */,\n                //                           cl_uint                /* num_mem_objects */,\n                //                           const cl_mem *         /* mem_objects */,\n                //                           cl_mem_migration_flags /* flags */,\n                //                           cl_uint                /* num_events_in_wait_list */,\n                //                           const cl_event *       /* event_wait_list */,\n                //                           cl_event *             /* event */) CL_API_SUFFIX__VERSION_1_2;\n                clEnqueueMigrateMemObjects: [\"int\", [types.CommandQueue, \"uint\", types.MemArray, types.MemMigrationFlags, \"uint\", types.EventArray, types.EventRef]],\n\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clEnqueueMarkerWithWaitList(cl_command_queue /* command_queue */,\n                //                            cl_uint           /* num_events_in_wait_list */,\n                //                            const cl_event *  /* event_wait_list */,\n                //                            cl_event *        /* event */) CL_API_SUFFIX__VERSION_1_2;\n                clEnqueueMarkerWithWaitList: [\"int\", [types.CommandQueue, \"uint\", types.EventArray, types.EventRef]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clEnqueueBarrierWithWaitList(cl_command_queue /* command_queue */,\n                //                             cl_uint           /* num_events_in_wait_list */,\n                //                             const cl_event *  /* event_wait_list */,\n                //                             cl_event *        /* event */) CL_API_SUFFIX__VERSION_1_2;\n                clEnqueueBarrierWithWaitList: [\"int\", [types.CommandQueue, \"uint\", types.EventArray, types.EventRef]],\n\n                //extern CL_API_ENTRY void * CL_API_CALL\n                //clGetExtensionFunctionAddressForPlatform(cl_platform_id /* platform */,\n                //                                         const char *   /* func_name */) CL_API_SUFFIX__VERSION_1_2;\n                clGetExtensionFunctionAddressForPlatform: [\"pointer\", [types.PlatformId, \"string\"]],\n\n                //extern CL_API_ENTRY cl_int CL_API_CALL\n                //clGetKernelArgInfo(cl_kernel       /* kernel */,\n                //                   cl_uint         /* arg_indx */,\n                //                   cl_kernel_arg_info  /* param_name */,\n                //                   size_t          /* param_value_size */,\n                //                   void *          /* param_value */,\n                //                   size_t *        /* param_value_size_ret */) CL_API_SUFFIX__VERSION_1_2;\n                clGetKernelArgInfo: [\"int\", [types.Kernel, \"uint\", types.KernelArgInfo, \"size_t\", \"pointer\", ref.refType(\"size_t\")]],\n\n                //extern CL_API_ENTRY cl_program CL_API_CALL\n                //clCreateProgramWithBuiltInKernels(cl_context            /* context */,\n                //                                  cl_uint               /* num_devices */,\n                //                                  const cl_device_id *  /* device_list */,\n                //                                  const char *          /* kernel_names */,\n                //                                  cl_int *              /* errcode_ret */) CL_API_SUFFIX__VERSION_1_2;\n                clCreateProgramWithBuiltInKernels: [types.Program, [types.Context, \"uint\", types.DeviceIdArray, \"string\", types.ErrorCodeRet]]\n            }));\n}\n\nutil.inherits(CL12, CL11);\n\nmodule.exports = CL12;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clPlatform.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# CLPlatform class\n\nRepresents an OpenCL platform.\n\n**base:** [CLWrapper](clWrapper.html)\n\n**Properties:**\n- [name](#name)\n- [vendor](#vendor)\n- [clVersion](#clversion)\n- [profile](#profile)\n- [extensions](#extensions)\n\n**Methods:**\n- [constructor](#constructor)\n- [getDevices](#getdevices)\n- [allDevices](#alldevices)\n- [cpuDevices](#cpudevices)\n- [accelDevices](#acceldevices)\n*/\n\n\"use strict\";\n\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar CLDevice = require(\"./clDevice\");\nvar clPredef = require(\"./clPredef\");\n\n/* ## constructor\n\n**arguments:**\n- **cl:**: object of type [CL11](cl11.html)\n- **handle:**: OpenCL handle\n */\nfunction CLPlatform(cl, handle) {\n    CLWrapper.call(this, cl, handle, null);\n}\n\nutil.inherits(CLPlatform, CLWrapper);\n\nObject.defineProperties(CLPlatform.prototype, {\n    _classInfoFunction: {\n        value: \"clGetPlatformInfo\"\n    },\n    // ## name\n    // The name of the platform.\n    name: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_PLATFORM_NAME);\n        }\n    },\n    // ## vendor\n    // Platform\"s vendor.\n    vendor: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_PLATFORM_VENDOR);\n        }\n    },\n    // ## clVersion\n    // Platform\"s version.\n    clVersion: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_PLATFORM_VERSION);\n        }\n    },\n    // ## profile\n    // Platform\"s profile..\n    profile: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_PLATFORM_PROFILE);\n        }\n    },\n    // ## extensions\n    // Available extensions.\n    extensions: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_PLATFORM_EXTENSIONS);\n        }\n    }\n});\n\n/* ## getDevices\n\n**arguments:**\n- **deviceType**: combination of the CL_DEVICE_TYPE_* flags\n\n** result: **\n\nArray of [CLDevice](clDevice.html) instances.\n*/\nCLPlatform.prototype.getDevices = function (deviceType) {\n    this._throwIfReleased();\n    var i, device, devNumVersion;\n    var devices = [];\n    var num = clPredef.num;\n    // _OpenCL API_: [clGetDeviceIDs](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceIDs.html)\n    var err = this.cl.imports.clGetDeviceIDs(this.handle, deviceType, 0, null, num);\n    if (err === this.cl.defs.CL_DEVICE_NOT_FOUND) {\n        return devices;\n    }\n    this.cl.checkError(err);\n\n    var n = num.deref();\n    if (!n) {\n        return devices;\n    }\n\n    var deviceIDs = new (this.cl.types.DeviceIdArray)(n);\n    // _OpenCL API_: [clGetDeviceIDs](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clGetDeviceIDs.html)\n    err = this.cl.imports.clGetDeviceIDs(this.handle, deviceType, n, deviceIDs, null);\n    this.cl.checkError(err);\n\n    for (i = 0; i < n; i++) {\n        device = new CLDevice(this.cl, deviceIDs.get(i), this);\n        devNumVersion = device.numVersion;\n        if (devNumVersion >= this.cl.version) {\n            devices.push(device);\n        }\n    }\n    return devices;\n};\n\n/* ## allDevices\n\n**returns:**\n\nArray of all available devices ([CLDevice](clDevice.html) instances).\n */\nCLPlatform.prototype.allDevices = function () {\n    this._throwIfReleased();\n    return this.getDevices(this.cl.defs.CL_DEVICE_TYPE_ALL);\n};\n\n/* ## cpuDevices\n\n**returns:**\n\nArray of CPU devices ([CLDevice](clDevice.html) instances).\n */\nCLPlatform.prototype.cpuDevices = function () {\n    this._throwIfReleased();\n    return this.getDevices(this.cl.defs.CL_DEVICE_TYPE_CPU);\n};\n\n/* ## gpuDevices\n\n**returns:**\n\nArray of GPU devices ([CLDevice](clDevice.html) instances).\n */\nCLPlatform.prototype.gpuDevices = function () {\n    this._throwIfReleased();\n    return this.getDevices(this.cl.defs.CL_DEVICE_TYPE_GPU);\n};\n\n/* ## accelDevices\n\n**returns:**\n\nArray of accelerator devices ([CLDevice](clDevice.html) instances).\n */\nCLPlatform.prototype.accelDevices = function () {\n    this._throwIfReleased();\n    return this.getDevices(this.cl.defs.CL_DEVICE_TYPE_ACCELERATOR);\n};\n\nmodule.exports = CLPlatform;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clWrapper.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# CLWrapper abstract class\n\nBase class of OpenCL wrapper classes.\n\n**base:** Object\n\n**Properties:**\n- [cl](#cl)\n- [handle](#handle)\n- [version](#version)\n\n**Methods:**\n- [constructor](#constructor)\n- [createReleaseFunction](#createReleaseFunction)\n- [release](#release)\n*/\n\n\"use strict\";\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar Disposable = fastcall.Disposable.Legacy;\nvar ref = fastcall.ref;\nvar ArrayType = fastcall.ArrayType;\nvar clUtils = require(\"./clUtils\");\nvar CL11 = require(\"./cl11\");\nvar assert = require(\"assert\");\nvar util = require(\"util\");\n\n/* ## constructor\n\n**arguments:**\n- **cl:**: object of type [CL11](cl11.html)\n- **handle:**: OpenCL handle\n*/\nfunction CLWrapper(cl, handle, releaseFunction) {\n    assert(cl instanceof CL11, \"Argument 'cl' is not a CL11 instance.\");\n    assert(ref.getType(handle) === ref.types.void, \"Argument 'handle' is not a pointer.\");\n    assert(!ref.isNull(handle), \"Handle is null.\");\n\n    Disposable.call(this, releaseFunction);\n\n    // ## object of type [CL11](cl11.html)\n    this.cl = cl;\n\n    // ## the OpenCL object handle\n    this.handle = handle;\n\n    this._cache = {};\n    this._infoFunction = this.cl.imports[this._classInfoFunction];\n}\n\nutil.inherits(CLWrapper, Disposable);\n\nObject.defineProperties(CLWrapper.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            this._ni(\"get _classInfoFunction\");\n        }\n    },\n    // ## version\n    // Returns the current OpenCL platform\"s version (see [CL11](cl11.html) version property)\n    version: {\n        get: function () {\n            return this.cl.version;\n        }\n    }\n});\n\nCLWrapper._releaseFunction = function (func) {\n    return func;\n}\n\nCLWrapper.prototype._ni = function (method) {\n    throw new Error(\"Not implemented: \" + method);\n};\n\nCLWrapper.prototype._throwIfReleased = function () {\n    if (this._released) {\n        throw new Error(this.constructor.name + \" object already released.\");\n    }\n};\n\nCLWrapper.prototype._cached = function (key, f, noCache) {\n    if (!noCache) {\n        var value = this._cache[key];\n        if (!_.isUndefined(value)) {\n            return value;\n        }\n    }\n\n    var result = f();\n\n    if (!noCache) {\n        this._cache[key] = result;\n    }\n\n    return result;\n};\n\n/* ## release\n\nReleases the underlying OpenCL object.\n*/\nCLWrapper.prototype.release = function () {\n    this.dispose();\n};\n\nCLWrapper.prototype._getInfo = function (elemType, infoName, noCache) {\n    return this._getInfoWith(this._infoFunction, elemType, infoName, noCache);\n};\n\nCLWrapper.prototype._getInfoWith = function (infoFunction, elemType, infoName, noCache) {\n    var self = this;\n    return this._cached(\n        infoName,\n        function () {\n            elemType = ref.coerceType(elemType);\n\n            var info = ref.alloc(elemType);\n            var err = infoFunction(self.handle, infoName, elemType.size || ref.sizeof.pointer, info, null);\n            self.cl.checkError(err);\n            var result = info.deref();\n\n            return result;\n        },\n        noCache\n    );\n};\n\nCLWrapper.prototype._getInfo2 = function (elemType, altFunction, device, infoName, noCache) {\n    var self = this;\n    return this._cached(\n        infoName,\n        function () {\n            elemType = ref.coerceType(elemType);\n\n            var info = ref.alloc(elemType);\n            var err = altFunction(self.handle, clUtils.toHandle(device), infoName, elemType.size || ref.sizeof.pointer, info, null);\n            self.cl.checkError(err);\n            var result = info.deref();\n\n            return result;\n        },\n        noCache\n    );\n};\n\nCLWrapper.prototype._getArrayInfo = function (elemType, infoName, noCache) {\n    var self = this;\n    return this._cached(\n        infoName,\n        function () {\n            var i;\n            elemType = ref.coerceType(elemType);\n\n            var needed = ref.alloc(\"size_t\");\n\n            var err = self._infoFunction(self.handle, infoName, 0, null, needed);\n            self.cl.checkError(err);\n\n            var nNeeded = needed.deref();\n\n            if (nNeeded === 0) {\n                // e.g. CL_CONTEXT_PROPERTIES can return needed = 0\n                return null;\n            }\n\n            var elemSize = elemType.size || ref.sizeof.pointer;\n            var bufferSize = nNeeded / elemSize;\n            var ElemTypeArray = new ArrayType(elemType);\n            var buffer = new ElemTypeArray(bufferSize);\n            err = self._infoFunction(self.handle, infoName, nNeeded, buffer.buffer, null);\n            self.cl.checkError(err);\n\n            var result = [];\n            for (i = 0; i < bufferSize; i++) {\n                result.push(buffer.get(i));\n            }\n\n            return result;\n        },\n        noCache\n    );\n};\n\nCLWrapper.prototype._getStringInfo = function (infoName, noCache) {\n    var self = this;\n    return this._cached(\n        infoName,\n        function () {\n            var arr = self._getArrayInfo(\"char\", infoName, true);\n            var str = arr.filter(function (code) {\n                return code > 0;\n            }).map(function (code) {\n                return String.fromCharCode(code);\n            }).join(\"\").trim();\n            return str;\n        },\n        noCache\n    );\n};\n\nCLWrapper.prototype._getArrayInfo2 = function (elemType, altFunction, device, infoName, noCache) {\n    var self = this;\n    return this._cached(\n        infoName,\n        function () {\n            var i;\n            var handle = clUtils.toHandle(device);\n            elemType = ref.coerceType(elemType);\n\n            var needed = ref.alloc(\"size_t\");\n\n            var err = altFunction(self.handle, handle, infoName, 0, null, needed);\n            self.cl.checkError(err);\n\n            var nNeeded = needed.deref();\n\n            if (nNeeded === 0) {\n                // e.g. CL_CONTEXT_PROPERTIES can return needed = 0\n                return null;\n            }\n\n            var elemSize = elemType.size || ref.sizeof.pointer;\n            var bufferSize = nNeeded / elemSize;\n            var ElemTypeArray = new ArrayType(elemType);\n            var buffer = new ElemTypeArray(bufferSize);\n            err = altFunction(self.handle, handle, infoName, nNeeded, buffer.buffer, null);\n            self.cl.checkError(err);\n\n            var result = [];\n            for (i = 0; i < bufferSize; i++) {\n                result.push(buffer.get(i));\n            }\n\n            return result;\n        },\n        noCache\n    );\n};\n\nCLWrapper.prototype._getStringInfo2 = function (altFunction, device, infoName, noCache) {\n    var self = this;\n    return this._cached(\n        infoName,\n        function () {\n            var arr = self._getArrayInfo2(\"char\", altFunction, device, infoName, true);\n            var str = arr.filter(function (code) {\n                return code > 0;\n            }).map(function (code) {\n                return String.fromCharCode(code);\n            }).join(\"\").trim();\n            return str;\n        },\n        noCache\n    );\n};\n\nmodule.exports = CLWrapper;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clUtils.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n\"use strict\";\nvar _ = require(\"lodash\");\nvar types = require(\"./types\");\nvar clPredef = require(\"./clPredef\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\n\nvar clUtils = {\n    toPtr: function (ptr, name) {\n        if (ptr === null) {\n            return null;\n        }\n        if (ptr instanceof Buffer) {\n            return ptr;\n        }\n        if (ptr && ptr.buffer instanceof Buffer) {\n            return ptr.buffer;\n        }\n        throw new TypeError(\"Pointer '\" + (name || \"ptr\") + \"' is not a buffer.\");\n    },\n\n    toHandle: function (obj, name) {\n        if (obj instanceof Buffer) {\n            return obj;\n        }\n        if (obj && obj.handle instanceof Buffer) {\n            return obj.handle;\n        }\n        throw new TypeError(\"Object '\" + (name || \"obj\") + \"' is not an OpenCL object.\");\n    },\n\n    isHandle: function (obj) {\n        if (obj instanceof Buffer) {\n            return true;\n        }\n        if (obj && obj.handle instanceof Buffer) {\n            return true;\n        }\n        return false;\n    },\n\n    createDeviceArray: function (devices) {\n        var i;\n        if (!_.isArray(devices)) {\n            devices = [devices];\n        }\n        var deviceArray = new (types.DeviceIdArray)(devices.length);\n        for (i = 0; i < devices.length; i++) {\n            deviceArray.set(i, devices[i].handle);\n        }\n        return deviceArray;\n    },\n\n    asImageFormat: function (format) {\n        if (!format.constructor || format.constructor.name !== \"StructType\") {\n            var format2 = clPredef.imageFormat;\n            format2.imageChannelOrder = format.imageChannelOrder;\n            format2.imageChannelDataType = format.imageChannelDataType;\n            format = format2;\n        }\n        return format;\n    },\n\n    createPropArray: function (cl, properties, platform) {\n        var i, c;\n        var propCount = _.isArray(properties) ? properties.length : 0;\n        var allPropCount = 2 + propCount + 1;\n        var propArray = new (cl.types.ContextProperties)(allPropCount);\n        propArray.set(0, cl.defs.CL_CONTEXT_PLATFORM);\n        propArray.set(1, ref.address(clUtils.toHandle(platform)));\n        for (i = 2, c = 0; c < propCount; i++, c++) {\n            propArray.set(i, properties[c]);\n        }\n        propArray.set(i, 0);\n        return propArray;\n    },\n\n    keepAlive: function(promise) {\n        var to = setTimeout(_.noop, 1000 * 60 * 60);\n        return promise.finally(function() {\n            clearTimeout(to);\n        });\n    }\n};\n\nmodule.exports = clUtils;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clPredef.js":"\"use strict\";\n\nvar types = require(\"./types\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\n\nvar clPredef = {\n    imageFormat: new (types.ImageFormat)(),\n    err: ref.alloc(types.ErrorCode),\n    num: ref.alloc(\"uint\")\n};\n\nmodule.exports = clPredef;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clDevice.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# CLDevice class\n\nRepresents an OpenCL device.\n\n**base:** Object\n\n**Properties:**\n\n[See below.](#device-properties)\n\n**Methods:**\n- [constructor](#constructor)\n*/\n\n\"use strict\";\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\n\nvar CLPlatform = null;\n\nfunction createReleaseFunction(cl, handle) {\n    if (cl.version >= 1.2) {\n        return CLWrapper._releaseFunction(function () {\n            cl.imports.clReleaseDevice(handle);\n        });\n    }\n    return null;\n}\n\n/* ## constructor\n\n**arguments:**\n- **cl:**: object of type [CL11](cl11.html)\n- **handle:**: OpenCL handle\n- **platform**: Owner [CLPlatform](clPlatform.html) instance (optional)\n*/\nfunction CLDevice(cl, handle, platform) {\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n    this._platform = platform;\n}\n\nutil.inherits(CLDevice, CLWrapper);\n\nObject.defineProperties(CLDevice.prototype, {\n    _classInfoFunction: {\n        value: \"clGetDeviceInfo\"\n    },\n    // ## Device properties\n    // ### deviceType\n    // Type of the device: CL_DEVICE_TYPE_CPU, CL_DEVICE_TYPE_GPU, etc.\n    deviceType: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.DeviceType, this.cl.defs.CL_DEVICE_TYPE);\n        }\n    },\n    // ### platform\n    // The owner [CLPlatform](clPlatform.html).\n    platform: {\n        get: function() {\n            this._throwIfReleased();\n            CLPlatform = CLPlatform || (CLPlatform = require(\"./clPlatform\"));\n            if (!(this._platform instanceof CLPlatform)) {\n                this._platform = new CLPlatform(this.cl, this._getInfo(this.cl.types.PlatformId, this.cl.defs.CL_DEVICE_PLATFORM));\n            }\n            return this._platform;\n        }\n    },\n\n    // ### vendorID\n    // A unique device vendor identifier. (e.g. PCIe ID)\n    vendorID: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_VENDOR_ID);\n        }\n    },\n\n    // ### maxComputeUnits\n    // The number of parallel compute cores on the OpenCL device (min. 1)\n    maxComputeUnits: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_COMPUTE_UNITS);\n        }\n    },\n\n    /* ### maxWorkItemDimensions\n    Maximum dimensions that specify the global and local work-item IDs used by\n    the data parallel execution model. (Refer to clEnqueueNDRangeKernel)\n    The minimum value is 3.*/\n    maxWorkItemDimensions: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_WORK_ITEM_DIMENSIONS);\n        }\n    },\n\n    /* ### maxWorkItemSizes\n    Maximum number of work-items that can be specified in each dimension of\n    the work-group to clEnqueueNDRangeKernel.\n\n    The minimum value is (1, 1, 1).\n\n    **returns:**\n\n    n size_t entries, where n is the value returned by the query for maxWorkItemDimensions.\n    */\n    maxWorkItemSizes: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getArrayInfo(\"size_t\", this.cl.defs.CL_DEVICE_MAX_WORK_ITEM_SIZES);\n        }\n    },\n\n    /* ### maxWorkgroupSize\n    Maximum number of work-items in a work-group executing a kernel using the data parallel execution model.\n    (Refer to [clEnqueueNDRangeKernel](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clEnqueueNDRangeKernel.html)).\n\n    The minimum value is 1.\n     */\n    maxWorkgroupSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_MAX_WORK_GROUP_SIZE);\n        }\n    },\n\n    // ### maxClockFrequency\n    // Maximum configured clock frequency of the device in MHz\n    maxClockFrequency: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_CLOCK_FREQUENCY);\n        }\n    },\n\n    /* ### addressBits\n    The default compute device address space size specified as an unsigned integer value in bits.\n    Currently supported values are 32 or 64 bits.\n    */\n    addressBits: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_ADDRESS_BITS);\n        }\n    },\n\n    /* ### maxMemAllocSize\n    Max size of memory object allocation in bytes.\n    The minimum value is max(1/4 * CL_DEVICE_GLOBAL_MEM_SIZE, 128*1024*1024)\n    */\n    maxMemAllocSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint64\", this.cl.defs.CL_DEVICE_MAX_MEM_ALLOC_SIZE);\n        }\n    },\n\n    // ### imageSupport\n    // true if images are supported by the OpenCL device\n    imageSupport: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.Bool, this.cl.defs.CL_DEVICE_IMAGE_SUPPORT);\n        }\n    },\n\n    /* ### maxReadImageArgs\n    Max number of simultaneous image objects that can be read by a kernel.\n    minimum value is 128 if imageSupport is true\n    */\n    maxReadImageArgs: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_READ_IMAGE_ARGS);\n        }\n    },\n\n    /* ### maxWriteImageArgs\n    Max number of simultaneous image objects that can be written by a kernel.\n    minimum value is 8 if imageSupport is true\n    */\n    maxWriteImageArgs: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_WRITE_IMAGE_ARGS);\n        }\n    },\n\n    /* ### image2DMaxWidth\n    Max width of 2D image in pixels.\n    minimum value is 8192 if imageSupport is true\n    */\n    image2DMaxWidth: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_IMAGE2D_MAX_WIDTH);\n        }\n    },\n\n    /* ### image2DMaxHeight\n    Max height of 2D image in pixels.\n    minimum value is 8192 if imageSupport is true\n    */\n    image2DMaxHeight: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_IMAGE2D_MAX_HEIGHT);\n        }\n    },\n\n    /* ### image3DMaxWidth\n    Max width of 3D image in pixels.\n    minimum value is 2048 if imageSupport is true\n    */\n    image3DMaxWidth: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_IMAGE3D_MAX_WIDTH);\n        }\n    },\n\n    /* ### image3DMaxHeight\n    Max height of 3D image in pixels.\n    minimum value is 2048 if imageSupport is true\n    */\n    image3DMaxHeight: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_IMAGE3D_MAX_HEIGHT);\n        }\n    },\n\n    /* ### image3DMaxDepth\n    Max depth of 3D image in pixels.\n    minimum value is 2048 if imageSupport is true\n    */\n    image3DMaxDepth: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_IMAGE3D_MAX_DEPTH);\n        }\n    },\n\n    /* ### maxSamplers\n    Maximum number of samplers that can be used in a kernel.\n    minimum value is 16 if imageSupport is true\n    */\n    maxSamplers: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_SAMPLERS);\n        }\n    },\n\n    /* ### maxParameterSize\n    Max size in bytes of the arguments that can be passed to a kernel.\n\n    The minimum value is 1024. For this minimum value, only a maximum of\n    128 arguments can be passed to a kernel\n    */\n    maxParameterSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_MAX_PARAMETER_SIZE);\n        }\n    },\n\n    /* ### memBaseAddrAlign\n    The minimum value is the size (in bits) of the largest OpenCL built-in data\n    type supported by the device (long16 in FULL profile, long16 or int16 in EMBEDDED profile).\n    */\n    memBaseAddrAlign: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MEM_BASE_ADDR_ALIGN);\n        }\n    },\n\n    /* ### minDataTypeAlignSize\n    The minimum value is the size (in bytes) of the largest OpenCL builtin\n    data type supported by the device (long16 in FULL profile, long16 or int16 in EMBEDDED profile).\n    */\n    minDataTypeAlignSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MIN_DATA_TYPE_ALIGN_SIZE);\n        }\n    },\n\n    // ### singleFpConfig\n    // Describes single precision floating-point capability of the device. This is a bit-field, see the docs\n    singleFpConfig: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.DeviceFpConfig, this.cl.defs.CL_DEVICE_SINGLE_FP_CONFIG);\n        }\n    },\n\n    // ### doubleFpConfig\n    // Describes double precision floating-point capability of the device. Make sure the cl_khr_fp64 extension is supported\n    doubleFpConfig: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.DeviceFpConfig, this.cl.defs.CL_DEVICE_DOUBLE_FP_CONFIG);\n        }\n    },\n\n    /* ### globalMemCacheType\n    Type of global memory cache supported. Valid values are:\n    CL_NONE, CL_READ_ONLY_CACHE and CL_READ_WRITE_CACHE\n    */\n    globalMemCacheType: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.DeviceMemCacheType, this.cl.defs.CL_DEVICE_GLOBAL_MEM_CACHE_TYPE);\n        }\n    },\n\n    // ### globalMemCacheLineSize\n    // size of global memory cache line in bytes.\n    globalMemCacheLineSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_GLOBAL_MEM_CACHELINE_SIZE);\n        }\n    },\n\n    // ### globalMemCacheSize\n    // size of global memory cache in bytes.\n    globalMemCacheSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint64\", this.cl.defs.CL_DEVICE_GLOBAL_MEM_CACHE_SIZE);\n        }\n    },\n\n    // ### globalMemSize\n    // size of global device memory in bytes.\n    globalMemSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint64\", this.cl.defs.CL_DEVICE_GLOBAL_MEM_SIZE);\n        }\n    },\n\n    // ### maxConstBufferSize\n    // Max size in bytes of a constant buffer allocation (min. 64 KB)\n    maxConstBufferSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint64\", this.cl.defs.CL_DEVICE_MAX_CONSTANT_BUFFER_SIZE);\n        }\n    },\n\n    // ### maxConstArgs\n    // Max number of arguments declared with the __constant qualifier in a kernel (min. 8)\n    maxConstArgs: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_DEVICE_MAX_CONSTANT_ARGS);\n        }\n    },\n\n    /* ### localMemType\n    Type of local memory supported.\n    This can be set to CL_LOCAL implying dedicated local memory storage such as SRAM, or CL_GLOBAL\n    */\n    localMemType: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.DeviceLocalMemType, this.cl.defs.CL_DEVICE_LOCAL_MEM_TYPE);\n        }\n    },\n\n    // ### localMemSize\n    // Size of local memory arena in bytes. The minimum value is 32 KB.\n    localMemSize: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint64\", this.cl.defs.CL_DEVICE_LOCAL_MEM_SIZE);\n        }\n    },\n\n    // ### errorCorrectionSupport\n    // true if the device implements error correction for all accesses to compute device memory (global and constant)\n    errorCorrectionSupport: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.Bool, this.cl.defs.CL_DEVICE_ERROR_CORRECTION_SUPPORT);\n        }\n    },\n\n    // ### hostUnifiedMemory\n    // returns true if the device and the host have a unified memory subsystem\n    hostUnifiedMemory: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.Bool, this.cl.defs.CL_DEVICE_HOST_UNIFIED_MEMORY);\n        }\n    },\n\n    /* ### profilingTimerResolution\n    Describes the resolution of device timer.\n    This is measured in nanoseconds.\n    */\n    profilingTimerResolution: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_DEVICE_PROFILING_TIMER_RESOLUTION);\n        }\n    },\n\n    // ### littleEndian\n    // is device a little endian device?\n    littleEndian: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.Bool, this.cl.defs.CL_DEVICE_ENDIAN_LITTLE);\n        }\n    },\n\n    // ### available\n    // is device available?\n    available: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.Bool, this.cl.defs.CL_DEVICE_AVAILABLE);\n        }\n    },\n\n    /* ### compilerAvailable\n    does the implementation have a compiler to compile the program source?\n    This can be CL_FALSE for the embedded platform profile only.\n    */\n    compilerAvailable: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.Bool, this.cl.defs.CL_DEVICE_COMPILER_AVAILABLE);\n        }\n    },\n\n    /* ### deviceExecCapabilities\n    Describes the execution capabilities of the device.\n\n    **returns:**\n\n    a bit-field that describes one or more of the following values:\n\n    - CL_EXEC_KERNEL – The OpenCL device can execute OpenCL kernels.\n    - CL_EXEC_NATIVE_KERNEL – The OpenCL device can execute native kernels.\n\n    The mandated minimum capability is: CL_EXEC_KERNEL.\n    */\n    deviceExecCapabilities: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.DeviceExecCapabilities, this.cl.defs.CL_DEVICE_EXECUTION_CAPABILITIES);\n        }\n    },\n\n    /* ### commandQueueProperties\n    Describes the command-queue properties supported by the device.\n\n    **returns:**\n\n    a bit-field that describes one or more of the following values:\n\n    - CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE\n    - CL_QUEUE_PROFILING_ENABLE\n     */\n    commandQueueProperties: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.CommandQueueProperties, this.cl.defs.CL_DEVICE_QUEUE_PROPERTIES);\n        }\n    },\n\n    // ### name\n    // get device name\n    name: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DEVICE_NAME);\n        }\n    },\n\n    // ### vendor\n    // get device vendor\n    vendor: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DEVICE_VENDOR);\n        }\n    },\n\n    // ### driverVersion\n    // get device OpenCL driver version in the form major_number.minor_number\n    driverVersion: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DRIVER_VERSION);\n        }\n    },\n\n    /* ### profile\n\n    get OpenCL profile string\n\n    **returns:**\n\n    the profile name supported by the device.\n\n    The profile name returned can be one of the following strings:\n\n    - FULL_PROFILE - if the device supports the OpenCL specification\n    (functionality defined as part of the core specification and does not require\n    any extensions to be supported).)\n\n    - EMBEDDED_PROFILE - if the device supports the OpenCL embedded profile.\n     */\n    profile: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DEVICE_PROFILE);\n        }\n    },\n\n    /* ### clVersion\n    get OpenCL version string\n\n    **returns:**\n\n    OpenCL version supported by the device.\n\n    This version string has the following format:\n    OpenCL<space><major_version.minor_version><space><vendor-specific information>\n    */\n    clVersion: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DEVICE_VERSION);\n        }\n    },\n\n    /* ### clCVersion\n    Returns the highest OpenCL C version supported by the compiler for this device\n    */\n    clCVersion: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DEVICE_OPENCL_C_VERSION);\n        }\n    },\n\n    // ### numVersion\n    // Value of the clCVersion property converted to a number, like: 1.1 or 1.2\n    numVersion: {\n        get: function() {\n            var m = /^OpenCL\\sC\\s(.*)/.exec(this.clCVersion);\n            return parseFloat(m[1]);\n        }\n    },\n\n    /* ### extensions\n    get extensions supported by the device\n\n    **returns:**\n\n    Returns a space separated list of extension names\n    (the extension names themselves do not contain any spaces).\n    */\n    extensions: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_DEVICE_EXTENSIONS);\n        }\n    }\n});\n\nmodule.exports = CLDevice;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clContext.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# CLContext class\n\nRepresents an OpenCL context.\n\n**base:** [CLWrapper](clWrapper.html)\n\n**Properties:**\n- [numDevices](#numdevices)\n- [devices](#devices)\n- [contextProperties](#contextproperties)\n\n**Methods:**\n- [constructor](#constructor)\n- [createProgram](#createprogram)\n- [getSupportedImageFormats](#getsupportedimageformats)\n*/\n\n\"use strict\";\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar _ = require(\"lodash\");\nvar CLPlatform = require(\"./clPlatform\");\nvar CLDevice = require(\"./clDevice\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar clUtils = require(\"./clUtils\");\nvar clPredef = require(\"./clPredef\");\n\nvar CLProgram = null;\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseContext(handle);\n    });\n}\n\n/* #### constructor 1\nContext can be created from devices.\n\n**arguments:**\n- **devices:** a single [CLDevice](clDevice.html) instance or handle,\n    or an array of [CLDevice](clDevice.html) instances or handles\n*/\nfunction CLContext1(devices) {\n    var i;\n    var isArray = _.isArray(devices);\n    var deviceCount = isArray ? devices.length : 1;\n    var firstDevice = isArray ? devices[0] : devices;\n    if (!(firstDevice instanceof CLDevice)) {\n        throw new TypeError(\"Arguments unknown.\");\n    }\n    var cl = firstDevice.cl;\n    var deviceArray = new (cl.types.DeviceIdArray)(deviceCount);\n    if (isArray) {\n        for (i = 0; i < deviceCount; i++) {\n            deviceArray.set(i, clUtils.toHandle(devices[i]));\n        }\n    }\n    else {\n        deviceArray.set(0, clUtils.toHandle(devices));\n    }\n\n    var err = clPredef.err;\n    var handle = cl.imports.clCreateContext(null, deviceCount, deviceArray, null, null, err);\n\n    cl.checkError(err);\n\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n}\n\n/* #### constructor 2\n\nContext can be created for a platform.\n\n**arguments:**\n- **platform:** a [CLPlatform](clPlatform.html) instance or a handle\n- **deviceType:** CL_DEVICE_TYPE_CPU, CL_DEVICE_TYPE_GPU, etc.\n- **properties:** [clCreateContextFromType](https://www.khronos.org/registry/cl/sdk/1.2/docs/man/xhtml/clCreateContextFromType.html)\nAPI properties and values in an array, except CL_CONTEXT_PLATFORM, which is passed automatically.\n*/\nfunction CLContext2(platform, deviceType, properties) {\n    var cl = platform.cl;\n\n    deviceType = deviceType || cl.defs.CL_DEVICE_TYPE_ALL;\n\n    var propArray = clUtils.createPropArray(cl, properties, platform);\n\n    var err = clPredef.err;\n    var handle = cl.imports.clCreateContextFromType(propArray, deviceType, null, null, err);\n\n    cl.checkError(err);\n\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n}\n\n/*\n## constructor\n\n### [version 1](#constructor-1)\nContext can be created from devices.\n\n### [version 2](#constructor-2)\nContext can be created for a platform.\n*/\nfunction CLContext(arg) {\n    if (arg instanceof CLPlatform) {\n        CLContext2.apply(this, arguments);\n    }\n    else {\n        CLContext1.apply(this, arguments);\n    }\n}\n\nutil.inherits(CLContext, CLWrapper);\n\nObject.defineProperties(CLContext.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetContextInfo\";\n        }\n    },\n    // ## numDevices\n    // Number of supported devices\n    numDevices: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_CONTEXT_NUM_DEVICES);\n        }\n    },\n    // ## numDevices\n    // Array of supported devices as [CLDevice](clDevice.html) instances.\n    devices: {\n        get: function () {\n            this._throwIfReleased();\n            var cl = this.cl;\n            return this._getArrayInfo(cl.types.DeviceId, cl.defs.CL_CONTEXT_DEVICES)\n                .map(function (did) {\n                    return new CLDevice(cl, did);\n                });\n        }\n    },\n    // ## contextProperties\n    // Returns the properties and values of the context.\n    contextProperties: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getArrayInfo(\"size_t\", this.cl.defs.CL_CONTEXT_PROPERTIES);\n        }\n    }\n});\n\n/* ## createProgram\n\nCreates an OpenCL program ...\n\n### version 1\n\n... from source\n\n**arguments:**\n- **source:** OpenCL program source code string.\n\n### version 2\n\n... from binaries\n\n**arguments:**\n- **binaries:** array of Buffers or a single Buffer containing the precompiled program binaries\n- **devices:** corresponding CLDevice instances or handles for the above binaries\n\n**returns**:\n[CLProgram](clProgram.html) instance\n*/\nCLContext.prototype.createProgram = function (arg1, arg2) {\n    this._throwIfReleased();\n    CLProgram = CLProgram || (CLProgram = require(\"./clProgram\"));\n    return new CLProgram(this, arg1, arg2);\n};\n\n/* ## getSupportedImageFormats\n\n**arguments:**\n- **flags:** [cl_mem_flags](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/enums.html#cl_mem_flags)\n- **type:** [cl_mem_object_type](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/enums.html#cl_mem_object_type)\n\n**returns**:\n\nthe supported image formats represented in an array of the following objects:\n\n    {\n        imageChannelOrder: ...,\n        imageChannelDataType: ...\n    }\n*/\nCLContext.prototype.getSupportedImageFormats = function (flags, type) {\n    this._throwIfReleased();\n    var i;\n    var numFormats = ref.alloc(\"uint\");\n    var err = this.cl.imports.clGetSupportedImageFormats(this.handle, flags, type, 0, null, numFormats);\n\n    this.cl.checkError(err);\n\n    var num = numFormats.deref();\n    var resultArray = new (this.cl.types.ImageFormatArray)(num);\n\n    err = this.cl.imports.clGetSupportedImageFormats(this.handle, flags, type, num, resultArray, null);\n\n    this.cl.checkError(err);\n\n    var result = [];\n    var item;\n    for (i = 0; i < num; i++) {\n        item = resultArray.get(i);\n        result.push({\n            imageChannelOrder: item.imageChannelOrder,\n            imageChannelDataType: item.imageChannelDataType\n        });\n    }\n    return result;\n};\n\nmodule.exports = CLContext;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clBuffer.js":"\"use strict\";\n\nvar util = require(\"util\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar CLMemory = require(\"./clMemory\");\nvar clUtils = require(\"./clUtils\");\n\nfunction CLBuffer1(context, flags, dataSize, hostPtr) {\n    hostPtr = hostPtr || null;\n    var cl = context.cl;\n    var err = ref.alloc(cl.types.ErrorCode);\n    var handle = cl.imports.clCreateBuffer(clUtils.toHandle(context), flags, dataSize, clUtils.toPtr(hostPtr, \"hostPtr\"), err);\n    cl.checkError(err);\n    CLMemory.call(this, context, handle);\n}\n\nfunction CLBuffer2(context, handle) {\n    CLMemory.call(this, context, handle);\n}\n\nfunction CLBuffer() {\n    if (arguments.length === 2) {\n        CLBuffer2.apply(this, arguments);\n    }\n    else {\n        CLBuffer1.apply(this, arguments);\n    }\n}\n\nCLBuffer._wrap = function (context, readOrWriteOnly, hostPtr) {\n    var ptr = clUtils.toPtr(hostPtr, \"hostPtr\");\n    var flags = context.cl.defs.CL_MEM_USE_HOST_PTR;\n    if (readOrWriteOnly === \"readOnly\") {\n        flags |= context.cl.defs.CL_MEM_READ_ONLY;\n    }\n    else if (readOrWriteOnly === \"writeOnly\") {\n        flags |= context.cl.defs.CL_MEM_WRITE_ONLY;\n    }\n    return new CLBuffer(context, flags, ptr.length, ptr);\n};\n\nCLBuffer.wrap = function (context, hostPtr) {\n    return CLBuffer._wrap(context, null, hostPtr);\n};\n\nCLBuffer.wrapReadOnly = function (context, hostPtr) {\n    return CLBuffer._wrap(context, \"readOnly\", hostPtr);\n};\n\nCLBuffer.wrapWriteOnly = function (context, hostPtr) {\n    return CLBuffer._wrap(context, \"writeOnly\", hostPtr);\n};\n\nutil.inherits(CLBuffer, CLMemory);\n\nObject.defineProperties(CLBuffer.prototype, {\n    offset: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_MEM_OFFSET);\n        }\n    },\n    superBuffer: {\n        get: function () {\n            this._throwIfReleased();\n            var subHandle = this._getInfo(this.cl.types.Mem, this.cl.defs.CL_MEM_ASSOCIATED_MEMOBJECT);\n            return new CLBuffer(subHandle);\n        }\n    }\n});\n\nCLBuffer.prototype.createSubBuffer = function (flags, origin, size) {\n    this._throwIfReleased();\n    var reg = new (this.cl.types.BufferRegion)();\n    reg.origin = origin;\n    reg.size = size;\n    var pReg = reg.ref();\n    var err = ref.alloc(this.cl.types.ErrorCode);\n    var subHandle = this.cl.imports.clCreateSubBuffer(this.handle, flags, this.cl.defs.CL_BUFFER_CREATE_TYPE_REGION, pReg, err);\n    this.cl.checkError(err);\n    return new CLBuffer(this.context, subHandle);\n};\n\nmodule.exports = CLBuffer;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clMemory.js":"\"use strict\";\n\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar assert = require(\"assert\");\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseMemObject(handle);\n    });\n}\n\nfunction CLMemory(context, handle) {\n    CLWrapper.call(this, context.cl, handle, createReleaseFunction(context.cl, handle));\n    this.context = context;\n}\n\nutil.inherits(CLMemory, CLWrapper);\n\nObject.defineProperties(CLMemory.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetMemObjectInfo\";\n        }\n    },\n    mapCount: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_MEM_MAP_COUNT);\n        }\n    },\n    hostPtr: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"pointer\", this.cl.defs.CL_MEM_HOST_PTR);\n        }\n    },\n    size: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"size_t\", this.cl.defs.CL_MEM_SIZE);\n        }\n    },\n    memFlags: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.MemFlags, this.cl.defs.CL_MEM_FLAGS);\n        }\n    }\n});\n\nCLMemory.prototype.setDestructorCallback = function (cb) {\n    this._throwIfReleased();\n    assert(_.isFunction(cb));\n    var err = this.cl.imports.setDestructorCallback(this.handle, this.cl.types.MemObjectDestructorCallback.toPointer(cb), null);\n    this.cl.checkError(err);\n};\n\nCLMemory.prototype.getGLObjectInfo = function () {\n    this._throwIfReleased();\n    var gl_object_type = ref.alloc(\"uint\");\n    var gl_object_name = ref.alloc(\"uint\");\n    var err = this.cl.imports.clGetGLObjectInfo(gl_object_type, gl_object_name);\n    this.cl.checkError(err);\n    return {\n        glObjectType: gl_object_type.deref(),\n        glObjectName: gl_object_name.deref()\n    };\n};\n\nmodule.exports = CLMemory;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clCommandQueue.js":"\"use strict\";\n\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar CLEvent = require(\"./clEvent\");\nvar CLContext = require(\"./clContext\");\nvar CLDevice = require(\"./clDevice\");\nvar NDRange = require(\"./ndRange\");\nvar assert = require(\"assert\");\nvar clUtils = require(\"./clUtils\");\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseCommandQueue(handle);\n    });\n}\n\nfunction CLCommandQueue1(cl, handle) {\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n}\n\nfunction CLCommandQueue2(context, device, outOfOrder, profiling) {\n    var cl = context.cl;\n    outOfOrder = _.isBoolean(outOfOrder) ? outOfOrder : false;\n    profiling = _.isBoolean(profiling) ? profiling : false;\n    var err = ref.alloc(cl.types.ErrorCode);\n\n    var handle = cl.imports.clCreateCommandQueue(\n        clUtils.toHandle(context),\n        clUtils.toHandle(device),\n        (outOfOrder ? cl.defs.CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE : 0) | (profiling ? cl.defs.CL_QUEUE_PROFILING_ENABLE : 0),\n        err);\n    cl.checkError(err);\n\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n}\n\nfunction CLCommandQueue() {\n    if (arguments.length >= 2 && arguments[0] instanceof CLContext && arguments[1] instanceof CLDevice) {\n        CLCommandQueue2.apply(this, arguments);\n    }\n    else {\n        CLCommandQueue1.apply(this, arguments);\n    }\n    this.isWaitable = false;\n    this._notWaitableVersion = this;\n    this._waitableVersion = null;\n}\n\nutil.inherits(CLCommandQueue, CLWrapper);\n\nObject.defineProperties(CLCommandQueue.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetCommandQueueInfo\";\n        }\n    },\n    context: {\n        get: function () {\n            this._throwIfReleased();\n            return new CLContext(this.cl, this._getInfo(this.cl.types.Context, this.cl.defs.CL_QUEUE_CONTEXT));\n        }\n    },\n    device: {\n        get: function () {\n            this._throwIfReleased();\n            return new CLDevice(this.cl, this._getInfo(this.cl.types.DeviceId, this.cl.defs.CL_QUEUE_DEVICE));\n        }\n    },\n    properties: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.CommandQueueProperties, this.cl.defs.CL_QUEUE_PROPERTIES);\n        }\n    },\n    isOutOfOrder: {\n        get: function () {\n            this._throwIfReleased();\n            return (this.properties & this.cl.defs.CL_QUEUE_OUT_OF_ORDER_EXEC_MODE_ENABLE) ? true : false;\n        }\n    },\n    isProfilingEnabled: {\n        get: function () {\n            this._throwIfReleased();\n            return (this.properties & this.cl.defs.CL_QUEUE_PROFILING_ENABLE) ? true : false;\n        }\n    },\n    waitableVersion: {\n        get: function () {\n            this._throwIfReleased();\n            if (!this._waitableVersion) {\n                var err = this.cl.imports.clRetainCommandQueue(this.handle);\n                this.cl.checkError(err);\n                try {\n                    var newQueue = new CLCommandQueue(this.cl, this.handle);\n                    newQueue.isWaitable = true;\n                    newQueue._notWaitableVersion = this;\n                    newQueue._waitableVersion = newQueue;\n                    this._waitableVersion = newQueue;\n                }\n                catch (e) {\n                    this.cl.imports.clReleaseCommandQueue(this.handle);\n                    throw e;\n                }\n            }\n            return this._waitableVersion;\n        }\n    },\n    notWaitableVersion: {\n        get: function () {\n            this._throwIfReleased();\n            return this._notWaitableVersion;\n        }\n    }\n});\n\nCLCommandQueue.prototype._toWaitList = function (events) {\n    if (events && events.length) {\n        var array = new (this.cl.types.EventArray)(events.length);\n        for (var i = 0; i < events.length; i++) {\n            array.set(i, clUtils.toHandle(events[i]));\n        }\n        return {\n            count: events.length,\n            array: array\n        };\n    }\n    else {\n        return {\n            count: 0,\n            array: null\n        };\n    }\n};\n\nCLCommandQueue.prototype.waitable = function (value) {\n    value = (value || true) ? true : false;\n    if (this.isWaitable === value) {\n        return this;\n    }\n    return value ? this.waitableVersion : this.notWaitableVersion;\n};\n\nCLCommandQueue.prototype.flush = function () {\n    this._throwIfReleased();\n    var err = this.cl.imports.clFlush(this.handle);\n    this.cl.checkError(err);\n};\n\nCLCommandQueue.prototype.enqueueWaitForEvents = function (events) {\n    this._throwIfReleased();\n    if (!events.length) {\n        return;\n    }\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueWaitForEvents(this.handle, waitList.count, waitList.array);\n    this.cl.checkError(err);\n};\n\nCLCommandQueue.prototype.enqueueTask = function (kernel, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueTask(this.handle, clUtils.toHandle(kernel), waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueMarker = function () {\n    this._throwIfReleased();\n    var event = ref.alloc(this.cl.types.Event);\n    var err = this.cl.imports.clEnqueueMarker(this.handle, event);\n    this.cl.checkError(err);\n    return new CLEvent(this.cl, event.deref());\n};\n\nCLCommandQueue.prototype.enqueueBarrier = function () {\n    this._throwIfReleased();\n    var err = this.cl.imports.clEnqueueBarrier(this.handle);\n    this.cl.checkError(err);\n};\n\nCLCommandQueue.prototype.enqueueNDRangeKernel = function (kernel, globalRange, localRange, offset, events) {\n    this._throwIfReleased();\n    globalRange = globalRange || NDRange.nullRange;\n    localRange = localRange || NDRange.nullRange;\n    offset = offset || NDRange.nullRange;\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueNDRangeKernel(this.handle, clUtils.toHandle(kernel), globalRange.dimensions, offset.sizes, globalRange.sizes, localRange.sizes, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype._enqueueReadWriteBuffer = function (func, buffer, offset, size, ptr, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = func(this.handle, clUtils.toHandle(buffer), false, offset, size, clUtils.toPtr(ptr), waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueReadBuffer = function (buffer, offset, size, ptr, events) {\n    return this._enqueueReadWriteBuffer(this.cl.imports.clEnqueueReadBuffer, buffer, offset, size, ptr, events);\n};\n\nCLCommandQueue.prototype.enqueueWriteBuffer = function (buffer, offset, size, ptr, events) {\n    return this._enqueueReadWriteBuffer(this.cl.imports.clEnqueueWriteBuffer, buffer, offset, size, ptr, events);\n};\n\nCLCommandQueue.prototype.enqueueMapBuffer = function (buffer, flags, offset, size, out, events) {\n    this._throwIfReleased();\n    assert(_.isObject(out), \"Out must be an object.\");\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = ref.alloc(this.cl.types.ErrorCode);\n    var ptr = this.cl.imports.clEnqueueMapBuffer(this.handle, clUtils.toHandle(buffer), false, flags, offset, size, waitList.count, waitList.array, event, err);\n    this.cl.checkError(err);\n    out.ptr = ptr;\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueMapImage = function (image, flags, origin, region, out, events) {\n    this._throwIfReleased();\n    assert(_.isObject(out), \"Out must be an object.\");\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = ref.alloc(this.cl.types.ErrorCode);\n    var rowPitch = ref.alloc(\"size_t\");\n    var slicePitch = ref.alloc(\"size_t\");\n    var ptr = this.cl.imports.clEnqueueMapImage(this.handle, clUtils.toHandle(image), false, flags, origin.sizes, region.sizes, rowPitch, slicePitch, waitList.count, waitList.array, event, err);\n    this.cl.checkError(err);\n    out.ptr = ptr;\n    out.rowPitch = rowPitch.deref();\n    out.slicePitch = slicePitch.deref();\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueUnmapMemory = function (memory, ptr, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueUnmapMemObject(this.handle, clUtils.toHandle(memory), ptr, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueAcquireGLObjects = function () {\n    this._throwIfReleased();\n    throw new Error(\"TODO\");\n};\n\nCLCommandQueue.prototype.enqueueReleaseGLObjects = function () {\n    this._throwIfReleased();\n    throw new Error(\"TODO\");\n};\n\nCLCommandQueue.prototype._enqueueReadWriteImage = function (func, image, origin, region, ptr, rowPitch, slicePitch, events) {\n    this._throwIfReleased();\n    rowPitch = rowPitch || 0;\n    slicePitch = slicePitch || 0;\n\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = func(this.handle, clUtils.toHandle(image), false, origin.sizes, region.sizes, rowPitch, slicePitch, clUtils.toPtr(ptr), waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueReadImage = function (image, origin, region, ptr, rowPitch, slicePitch, events) {\n    return this._enqueueReadWriteImage(this.cl.imports.clEnqueueReadImage, image, origin, region, ptr, rowPitch, slicePitch, events);\n};\n\nCLCommandQueue.prototype.enqueueWriteImage = function (image, origin, region, ptr, rowPitch, slicePitch, events) {\n    return this._enqueueReadWriteImage(this.cl.imports.clEnqueueWriteImage, image, origin, region, ptr, rowPitch, slicePitch, events);\n};\n\nCLCommandQueue.prototype.enqueueCopyBuffer = function (srcBuffer, dstBuffer, srcOffset, dstOffset, size, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueCopyBuffer(this.handle, clUtils.toHandle(srcBuffer), clUtils.toHandle(dstBuffer), srcOffset, dstOffset, size, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueCopyImage = function (srcImage, dstImage, srcOrigin, dstOrigin, region, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueCopyImage(this.handle, clUtils.toHandle(srcImage), clUtils.toHandle(dstImage), srcOrigin.sizes, dstOrigin.sizes, region.sizes, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueCopyImageToBuffer = function (srcImage, dstBuffer, srcOrigin, region, dstOffset, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueCopyImageToBuffer(this.handle, clUtils.toHandle(srcImage), clUtils.toHandle(dstBuffer), srcOrigin.sizes, region.sizes, dstOffset, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueCopyBufferToImage = function (srcBuffer, dstImage, srcOffset, dstOrigin, region, events) {\n    this._throwIfReleased();\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueCopyImageToBuffer(this.handle, clUtils.toHandle(srcBuffer), clUtils.toHandle(dstImage), srcOffset, dstOrigin.sizes, region.sizes, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype._enqueueReadWriteBufferRect = function (func, buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events) {\n    this._throwIfReleased();\n\n    bufferRowPitch = bufferRowPitch || 0;\n    bufferSlicePitch = bufferSlicePitch || 0;\n    hostRowPitch = hostRowPitch || 0;\n    hostSlicePitch = hostSlicePitch || 0;\n\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = func(this.handle, clUtils.toHandle(buffer), false, bufferOrigin.sizes, hostOrigin.sizes, region.sizes, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, clUtils.toPtr(ptr), waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nCLCommandQueue.prototype.enqueueReadBufferRect = function (buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events) {\n    return this._enqueueReadWriteBufferRect(this.cl.imports.clEnqueueReadBufferRect, buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events);\n};\n\nCLCommandQueue.prototype.enqueueWriteBufferRect = function (buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events) {\n    return this._enqueueReadWriteBufferRect(this.cl.imports.clEnqueueWriteBufferRect, buffer, bufferOrigin, hostOrigin, region, ptr, bufferRowPitch, bufferSlicePitch, hostRowPitch, hostSlicePitch, events);\n};\n\nCLCommandQueue.prototype.enqueueCopyBufferRect = function (srcBuffer, dstBuffer, srcOrigin, dstOrigin, region, srcRowPitch, srcSlicePitch, dstRowPitch, dstSlicePitch, events) {\n    this._throwIfReleased();\n\n    srcRowPitch = srcRowPitch || 0;\n    srcSlicePitch = srcSlicePitch || 0;\n    dstRowPitch = dstRowPitch || 0;\n    dstSlicePitch = dstSlicePitch || 0;\n\n    var event = this.isWaitable ? ref.alloc(this.cl.types.Event) : null;\n    var waitList = this._toWaitList(events);\n    var err = this.cl.imports.clEnqueueCopyBufferRect(this.handle, clUtils.toHandle(srcBuffer), clUtils.toHandle(dstBuffer), srcOrigin.sizes, dstOrigin.sizes, region.sizes, srcRowPitch, srcSlicePitch, dstRowPitch, dstSlicePitch, waitList.count, waitList.array, event);\n    this.cl.checkError(err);\n    if (event) {\n        return new CLEvent(this.cl, event.deref());\n    }\n};\n\nmodule.exports = CLCommandQueue;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clEvent.js":"\"use strict\";\n\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar CLContext = require(\"./clContext\");\nvar Bluebird = require(\"bluebird\");\nvar assert = require(\"assert\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar clUtils = require(\"./clUtils\");\n\nvar CLCommandQueue = null;\n\n// CLEventProfilingInfo\n\nfunction CLEventProfilingInfo(cl, handle) {\n    CLWrapper.call(this, cl, handle, null);\n}\n\nutil.inherits(CLEventProfilingInfo, CLWrapper);\n\nObject.defineProperties(CLEventProfilingInfo.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetEventProfilingInfo\";\n        }\n    },\n    profilingCommandQueued: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"ulong\", this.cl.defs.CL_PROFILING_COMMAND_QUEUED, true);\n        }\n    },\n    profilingCommandSubmit: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"ulong\", this.cl.defs.CL_PROFILING_COMMAND_SUBMIT, true);\n        }\n    },\n    profilingCommandStart: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"ulong\", this.cl.defs.CL_PROFILING_COMMAND_START, true);\n        }\n    },\n    profilingCommandEnd: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"ulong\", this.cl.defs.CL_PROFILING_COMMAND_END, true);\n        }\n    }\n});\n\n//CLEvent\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseEvent(handle);\n    });\n}\n\nfunction CLEvent(cl, handle) {\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n    this.profilingInfo = new CLEventProfilingInfo(cl, handle);\n    this._promise = null;\n    this._cb = null;\n    this._icb = null;\n}\n\nutil.inherits(CLEvent, CLWrapper);\n\nObject.defineProperties(CLEvent.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetEventInfo\";\n        }\n    },\n    commandQueue: {\n        get: function () {\n            this._throwIfReleased();\n            CLCommandQueue = CLCommandQueue || (CLCommandQueue = require(\"./clCommandQueue\"));\n            return new CLCommandQueue(this.cl, this._getInfo(this.cl.types.CommandQueue, this.cl.defs.CL_EVENT_COMMAND_QUEUE));\n        }\n    },\n    context: {\n        get: function () {\n            this._throwIfReleased();\n            return new CLContext(this.cl, this._getInfo(this.cl.types.Context, this.cl.defs.CL_EVENT_CONTEXT));\n        }\n    },\n    commandType: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.CommandType, this.cl.defs.CL_EVENT_COMMAND_TYPE);\n        }\n    },\n    commandExecutionStatus: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(this.cl.types.CommandExecutionStatus, this.cl.defs.CL_EVENT_COMMAND_EXECUTION_STATUS, true);\n        }\n    },\n    promise: {\n        get: function () {\n            var self = this;\n            self._throwIfReleased();\n            if (self._promise) {\n                return self._promise;\n            }\n            var cl = self.cl;\n            var defer;\n            self._promise = new Bluebird(function (resolve, reject) {\n                defer = {\n                    resolve: resolve,\n                    reject: reject\n                };\n            });\n            this._icb = function (h, err2, data) {\n                try {\n                    cl.checkError(err2);\n                    if (err2 === 0) {\n                        defer.resolve();\n                    }\n                }\n                catch (e) {\n                    defer.reject(e);\n                }\n            };\n            this._cb = cl.types.SetEventCallbackCallback.toPointer(this._icb);\n            var err = cl.imports.clSetEventCallback(self.handle, cl.defs.CL_COMPLETE, this._cb, null);\n            cl.checkError(err);\n            self._promise = self._promise.finally(function() {\n                setImmediate(function () {\n                    self.release();\n                });\n            });\n            self._promise = clUtils.keepAlive(self._promise);\n            return self._promise;\n        }\n    }\n});\n\nmodule.exports = CLEvent;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/ndRange.js":"\"use strict\";\n\nvar _ = require(\"lodash\");\nvar types = require(\"./types\");\n\nfunction NDRange(xSize, ySize, zSize) {\n    if (_.isNumber(xSize)) {\n        ySize = _.isNumber(ySize) ? ySize : 0;\n        zSize = _.isNumber(zSize) ? zSize : 0;\n\n        this.sizes = new (types.SizeTArray)(3);\n        this.sizes.set(0, xSize);\n        this.sizes.set(1, ySize);\n        this.sizes.set(2, zSize);\n    }\n    else {\n        this.sizes = null;\n    }\n}\n\nObject.defineProperties(NDRange.prototype, {\n    dimensions: {\n        get: function () {\n            return this.sizes.get(2) !== 0 ? 3 : (this.sizes.get(1) !== 0 ? 2 : (this.sizes.get(0) !== 0 ? 1 : 0));\n        }\n    },\n    xSize: {\n        get: function() {\n            return this.sizes.get(0);\n        }\n    },\n    ySize: {\n        get: function() {\n            return this.sizes.get(1);\n        }\n    },\n    zSize: {\n        get: function() {\n            return this.sizes.get(2);\n        }\n    }\n});\n\nNDRange.nullRange = new NDRange();\n\nmodule.exports = NDRange;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clUserEvent.js":"\"use strict\";\n\nvar util = require(\"util\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar CLEvent = require(\"./clEvent\");\nvar clUtils = require(\"./clUtils\");\n\nfunction CLUserEvent(context) {\n    var cl = context.cl;\n    var err = ref.alloc(cl.types.ErrorCode);\n    var handle = cl.imports.clCreateUserEvent(clUtils.toHandle(context), err);\n    cl.checkError(err);\n    CLEvent.call(this, cl, handle);\n}\n\nutil.inherits(CLUserEvent, CLEvent);\n\nCLUserEvent.prototype.setStatus = function(status) {\n    this._throwIfReleased();\n    var err = this.cl.imports.clSetUserEventStatus(this.handle, status);\n    this.cl.checkError(err);\n};\n\nmodule.exports = CLUserEvent;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clProgram.js":"/*\nLicense: [MIT](../LICENSE)\n\nCopyright (c) 2014 Gábor Mező aka [unbornchikken](https://github.com/unbornchikken)\n*/\n\n/*\n# CLProgram class\n\nRepresents an OpenCL program.\n\n**base:** [CLWrapper](clWrapper.html)\n\n**Properties:**\n- [numDevices](#numdevices)\n- [devices](#devices)\n- [sourceCode](#sourcecode)\n\n**Methods:**\n- [constructor](#constructor)\n- [build](#build)\n- [createKernel](#createkernel)\n- [createAllKernels](#createallkernels)\n- [getBuildStatus](#getbuildstatus)\n- [getBuildOptions](#getbuildoptions)\n- [getBuildLog](#getbuildlog)\n- [getBuildLogs](#getbuildlogs)\n- [getBinaries](#getbinaries)\n*/\n\n\"use strict\";\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar CLContext = require(\"./clContext\");\nvar Bluebird = require(\"bluebird\");\nvar clUtils = require(\"./clUtils\");\nvar CLKernel = require(\"./clKernel\");\nvar clPredefs = require(\"./clPredef\");\n\nconst BUILD_ERROR_CODE = -11;\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseProgram(handle);\n    });\n}\n\n/* ### constructor 1\nProgram can be created from source.\n\n**arguments:**\n- **context:** Owner CLContext instance.\n- **source:** OpenCL program source code string.\n*/\nfunction CLProgram1(context, source) {\n    this.context = context;\n    var cl = context.cl;\n    var err = ref.alloc(cl.types.ErrorCode);\n    var lengths = new (cl.types.SizeTArray)(1);\n    lengths.set(0, source.length);\n    var sources = new (cl.types.StringArray)(1);\n    sources.set(0, source);\n    var handle = cl.imports.clCreateProgramWithSource(clUtils.toHandle(context), 1, sources, lengths, err);\n    cl.checkError(err);\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n}\n\n/* ### constructor 2\nProgram can be created from binaries.\n\n**arguments:**\n- **context:** Owner CLContext instance.\n- **binaries:** array of Buffers or a single Buffer containing the precompiled program binaries\n- **devices:** corresponding CLDevice instances or handles for the above binaries\n*/\nfunction CLProgram2(context, binaries, devices) {\n    this.context = context;\n    var cl = context.cl;\n    var err = ref.alloc(cl.types.ErrorCode);\n\n    if (!_.isArray(binaries)) {\n        binaries = [binaries];\n    }\n    var binaryArray = new (cl.types.Binaries)(binaries.length);\n    var binarySizes = new (cl.types.SizeTArray)(binaries.length);\n    for (var i = 0; i < binaries.length; i++) {\n        binaryArray.set(i, binaries[i]);\n        binarySizes.set(i, binaries[i].length);\n    }\n    var deviceArray = clUtils.createDeviceArray(devices);\n\n    var handle = cl.imports.clCreateProgramWithBinary(\n        clUtils.toHandle(context),\n        deviceArray.length,\n        deviceArray,\n        binarySizes,\n        binaryArray,\n        null,\n        err);\n\n    cl.checkError(err);\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n}\n\n/*\n## constructor\n\n### [version 1](#constructor-1)\nProgram can be created from source.\n\n### [version 2](#constructor-2)\nProgram can be created from binaries.\n*/\nfunction CLProgram() {\n    if (!(arguments[0] instanceof CLContext)) {\n        throw new TypeError(\"First argument must be a CLContext instance.\");\n    }\n    if (_.isString(arguments[1])) {\n        CLProgram1.apply(this, arguments);\n    }\n    else {\n        CLProgram2.apply(this, arguments);\n    }\n}\n\nutil.inherits(CLProgram, CLWrapper);\n\nObject.defineProperties(CLProgram.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetProgramInfo\";\n        }\n    },\n    // ## numDevices\n    // Number of devices\n    numDevices: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getInfo(\"uint\", this.cl.defs.CL_PROGRAM_NUM_DEVICES);\n        }\n    },\n    // ## numDevices\n    // Array of devices as [CLDevice](clDevice.html) instances.\n    devices: {\n        get: function () {\n            this._throwIfReleased();\n            var cl = this.cl;\n            var CLDevice = require(\"./clDevice\");\n            return this._getArrayInfo(cl.types.DeviceId, cl.defs.CL_PROGRAM_DEVICES).map(\n                function (did) {\n                    return new CLDevice(cl, did);\n                }\n            );\n        }\n    },\n    // ## sourceCode\n    // Source code string if program was created from source, null otherwise.\n    sourceCode: {\n        get: function () {\n            this._throwIfReleased();\n            return this._getStringInfo(this.cl.defs.CL_PROGRAM_SOURCE);\n        }\n    }\n});\n\n/* ## build\nCompiles a program source, or builds program from binaries.\n\n**arguments**:\n- **options:**: command line options, see [the platform API documentation](https://www.khronos.org/registry/cl/sdk/1.1/docs/man/xhtml/clBuildProgram.html)\n- **devices:**: array of CLDevice instances or handles or null.\nIf it is a non-null value, the program executable is built for devices specified in this list for which a source or binary has been loaded,\nif it\"s null the program executable is built for all devices associated with program for which a source or binary has been loaded.\n\n**returns:**\n\nA promise that resolves to no value.\n*/\nCLProgram.prototype.build = function (options, devices) {\n    this._throwIfReleased();\n    var self = this;\n    var cl = self.cl;\n    options = options || null;\n    var cbi, cb;\n    var promise = new Bluebird(function (resolve, reject) {\n        var done = false;\n        try {\n            cbi = function () {\n                if (!done) {\n                    try {\n                        resolve();\n                    }\n                    finally {\n                        done = true;\n                    }\n                }\n            };\n            cb = cl.types.BuildProgramNotify.toPointer(cbi);\n            var err = cl.imports.clBuildProgram(\n                self.handle,\n                devices ? devices.length : 0,\n                devices ? clUtils.createDeviceArray(devices) : null,\n                options,\n                cb,\n                null);\n            cl.checkError(err);\n        }\n        catch (e) {\n            if (!done) {\n                try {\n                    if (e.code = BUILD_ERROR_CODE) {\n                        return resolve();\n                    }\n                    reject(e);\n                }\n                finally {\n                    done = true;\n                }\n            }\n        }\n    });\n    promise._cb = cb;\n    promise._cbi = cbi;\n    return clUtils.keepAlive(promise);\n};\n\nCLProgram.prototype.createKernel = function (name) {\n    return new CLKernel(this, name);\n};\n\nCLProgram.prototype.createAllKernels = function () {\n    var numKernels = clPredefs.num;\n    var err = this.cl.imports.clCreateKernelsInProgram(this.handle, 0, null, numKernels);\n    this.cl.checkError(err);\n    var nk = numKernels.deref();\n    var kernels = new (this.cl.types.KernelArray)(nk);\n    err = this.cl.imports.clCreateKernelsInProgram(this.handle, nk, kernels, null);\n    this.cl.checkError(err);\n\n    var result = [];\n    for (var i = 0; i < nk; i++) {\n        result.push(new CLKernel(this, kernels.get(i)));\n    }\n    return result;\n};\n\nCLProgram.prototype.getBuildStatus = function (device) {\n    this._throwIfReleased();\n    return this._getInfo2(ref.types.int, this.cl.imports.clGetProgramBuildInfo, device, this.cl.defs.CL_PROGRAM_BUILD_STATUS, true);\n};\n\nCLProgram.prototype.getBuildOptions = function (device) {\n    this._throwIfReleased();\n    return this._getStringInfo2(this.cl.imports.clGetProgramBuildInfo, device, this.cl.defs.CL_PROGRAM_BUILD_OPTIONS, true);\n};\n\nCLProgram.prototype.getBuildLog = function (device) {\n    this._throwIfReleased();\n    return this._getStringInfo2(this.cl.imports.clGetProgramBuildInfo, device, this.cl.defs.CL_PROGRAM_BUILD_LOG, true);\n};\n\nCLProgram.prototype.getBuildLogs = function () {\n    this._throwIfReleased();\n    var self = this;\n    return this.context.devices.map(function (device) {\n        return self.getBuildLog(device);\n    }).join(\"\\n\");\n};\n\nCLProgram.prototype.getBinaries = function () {\n    this._throwIfReleased();\n    var cl = this.cl;\n    var sizes = this._getBinarySizes();\n    var binaries = new (cl.types.Binaries)(sizes.length);\n    var result = [];\n    for (var i = 0; i < sizes.length; i++) {\n        var bin = new (cl.types.Binary)(sizes.get(i));\n        binaries.set(i, bin.buffer);\n        result.push(bin.buffer);\n    }\n\n    var err = cl.imports.clGetProgramInfo(this.handle, cl.defs.CL_PROGRAM_BINARIES, binaries.length * ref.sizeof.pointer, binaries.buffer, null);\n\n    this.cl.checkError(err);\n\n    return result;\n};\n\nCLProgram.prototype._getBinarySizes = function () {\n    this._throwIfReleased();\n    var numDevices = this.numDevices;\n    var buffer = new (this.cl.types.SizeTArray)(numDevices);\n\n    // get actual data\n    var err = this.cl.imports.clGetProgramInfo(this.handle, this.cl.defs.CL_PROGRAM_BINARY_SIZES, numDevices * ref.sizeof.size_t, buffer.buffer, null);\n\n    // error checking\n    this.cl.checkError(err);\n\n    return buffer;\n};\n\nmodule.exports = CLProgram;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clKernel.js":"\"use strict\";\n\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar _ = require(\"lodash\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar clUtils = require(\"./clUtils\");\nvar KernelArg = require(\"./kernelArg\");\nvar assert = require(\"assert\");\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseKernel(handle);\n    });\n}\n\nfunction CLKernel1(program, name) {\n    var cl = program.cl;\n    var err = ref.alloc(cl.types.ErrorCode);\n    var handle = cl.imports.clCreateKernel(clUtils.toHandle(program), name, err);\n    cl.checkError(err);\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n    this.propgram = program;\n    this._name = name;\n}\n\nfunction CLKernel2(program, handle) {\n    var cl = program.cl;\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n    this.propgram = program;\n    this._name = null;\n}\n\nfunction CLKernel() {\n    if (_.isString(arguments[1])) {\n        CLKernel1.apply(this, arguments);\n    }\n    else {\n        CLKernel2.apply(this, arguments);\n    }\n    this._args = [];\n}\n\nutil.inherits(CLKernel, CLWrapper);\n\nObject.defineProperties(CLKernel.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetKernelInfo\";\n        }\n    },\n    name: {\n        get: function () {\n            return this._name ? this._name : this._getStringInfo(this.cl.defs.CL_KERNEL_FUNCTION_NAME);\n        }\n    },\n    context: {\n        get: function () {\n            return this.program.context;\n        }\n    },\n    numArgs: {\n        get: function () {\n            return this._getInfo(\"uint\", this.cl.defs.CL_KERNEL_NUM_ARGS);\n        }\n    }\n});\n\nCLKernel.prototype.getWorkgroupSize = function (device) {\n    return this._getInfo2(\"size_t\", this.cl.imports.clGetKernelWorkGroupInfo, device, this.cl.defs.CL_KERNEL_WORK_GROUP_SIZE);\n};\n\nCLKernel.prototype.getCompileWorkGroupSize = function (device) {\n    return this._getArrayInfo2(\"size_t\", this.cl.imports.clGetKernelWorkGroupInfo, device, this.cl.defs.CL_KERNEL_COMPILE_WORK_GROUP_SIZE);\n};\n\nCLKernel.prototype.getLocalMemSize = function (device) {\n    return this._getInfo2(\"ulong\", this.cl.imports.clGetKernelWorkGroupInfo, device, this.cl.defs.CL_KERNEL_LOCAL_MEM_SIZE);\n};\n\nCLKernel.prototype.getPreferredWorkGroupSizeMultiple = function (device) {\n    return this._getInfo2(\"size_t\", this.cl.imports.clGetKernelWorkGroupInfo, device, this.cl.defs.CL_KERNEL_PREFERRED_WORK_GROUP_SIZE_MULTIPLE);\n};\n\nCLKernel.prototype.getPrivateMemSize = function (device) {\n    return this._getInfo2(\"ulong\", this.cl.imports.clGetKernelWorkGroupInfo, device, this.cl.defs.CL_KERNEL_PRIVATE_MEM_SIZE);\n};\n\nCLKernel.prototype.setArg = function (index, value, type) {\n    assert(_.isNumber(index), \"Argument 'index' is not a number.\");\n    assert(index >= 0 && index < 2048, \"Argument 'index' is out of range.\");\n\n    while (this._args.length <= index) {\n        this._args.push(null);\n    }\n    if (_.isPlainObject(value) && _.isUndefined(type)) {\n        // Supporting formats like: { \"int\": 55 }\n        for (var k in value) {\n            if (value.hasOwnProperty(k)) {\n                type = k;\n                break;\n            }\n        }\n        if (type) {\n            value = value[type];\n        }\n    }\n    if (this._args[index] === null) {\n        this._args[index] = new KernelArg(this, index, value, type);\n    }\n    else {\n        this._args[index].value = value;\n    }\n};\n\nCLKernel.prototype.setArgs = function () {\n    var self = this;\n    _.forEach(_.isArray(arguments[0]) ? arguments[0] : arguments, function (arg, i) {\n        self.setArg(i, arg);\n    });\n};\n\nCLKernel.prototype.bind = function (queue, globalRange, localRange, offset) {\n    return function () {\n        this.setArgs.apply(this, arguments);\n        queue.waitable(false).enqueueNDRangeKernel(this, globalRange, localRange, offset);\n    }.bind(this);\n};\n\nmodule.exports = CLKernel;\n","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/kernelArg.js":"\"use strict\";\n\nvar clUtils = require(\"./clUtils\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar _ = require(\"lodash\");\n\nvar kernelArgKind = {\n    clObject: 0,\n    localSize: 1,\n    value: 2\n};\n\nfunction KernelArg(kernel, index, value, type) {\n    this.kernel = kernel;\n    this.index = index;\n    this.kind = 0;\n    this._value = value;\n    this._type = null;\n    this._valueBuffer = null;\n    this._set = null;\n    var setArg = this.kernel.cl.imports.clSetKernelArg;\n\n    if (this._value === null || clUtils.isHandle(this._value)) {\n        this.kind = kernelArgKind.clObject;\n        if (this._value !== null) {\n            this._value = clUtils.toHandle(this._value);\n            this._valueBuffer = ref.alloc(this.kernel.cl.types.Mem);\n            ref.set(this._valueBuffer, 0, this._value);\n        }\n        else {\n            this._valueBuffer = null;\n        }\n        this._set = function () {\n            this.kernel.cl.checkError(setArg(this.kernel.handle, this.index, ref.types.size_t.size, this._valueBuffer));\n        }.bind(this);\n    }\n    else if (_.isUndefined(type) || type === null) {\n        this.kind = kernelArgKind.localSize;\n        this._set = function () {\n            this.kernel.cl.checkError(setArg(this.kernel.handle, this.index, this._value, null));\n        }.bind(this);\n    }\n    else {\n        this.kind = kernelArgKind._value;\n        this._type = ref.coerceType(type);\n        this._valueBuffer = ref.alloc(this._type);\n        ref.set(this._valueBuffer, 0, this._value);\n        this._set = function () {\n            this.kernel.cl.checkError(setArg(this.kernel.handle, this.index, this._type.size, this._valueBuffer));\n        }.bind(this);\n    }\n\n    this._set();\n}\n\nKernelArg.kind = kernelArgKind;\n\nObject.defineProperties(KernelArg.prototype, {\n    value: {\n        get: function () {\n            return this._value;\n        },\n        set: function (to) {\n            if (this.kind === kernelArgKind.clObject) {\n                if (to === null) {\n                    if (this._value === null) {\n                        return;\n                    }\n                    this._value = null;\n                    this._set();\n                }\n                else {\n                    to = clUtils.toHandle(to, \"to\");\n                    if (this.value === null || ref.address(this._value) !== ref.address(to)) {\n                        this._value = clUtils.toHandle(this._value);\n                        ref.set(this._valueBuffer, 0, this._value);\n                        this._set();\n                    }\n                }\n            }\n            else if (this.kind === kernelArgKind.localSize) {\n                if (this._value !== to) {\n                    this._value = to;\n                    this._set();\n                }\n            }\n            else { // kernelArgKind.value\n                if (this._valueBuffer.deref() !== to) {\n                    this._value = to;\n                    ref.set(this._valueBuffer, 0, this._value);\n                    this._set();\n                }\n            }\n        }\n    }\n});\n\nmodule.exports = KernelArg;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clImage2D.js":"\"use strict\";\r\nvar util = require(\"util\");\r\nvar CLImage = require(\"./clImage\");\r\nvar clUtils = require(\"./clUtils\");\r\nvar clPredef = require(\"./clPredef\");\r\n\r\nfunction CLImage2D(context, flags, format, width, height, hostPtr, rowPitch) {\r\n    format = clUtils.asImageFormat(format);\r\n    hostPtr = hostPtr || null;\r\n    rowPitch = rowPitch || 0;\r\n    var cl = context.cl;\r\n\r\n    var err = clPredef.err;\r\n    var handle = cl.imports.clCreateImage2D(clUtils.toHandle(context, \"context\"), flags, format.ref(), width, height, rowPitch, clUtils.toPtr(hostPtr, \"hostPtr\"), err);\r\n    cl.checkError(err);\r\n\r\n    CLImage.call(this, context, handle);\r\n}\r\n\r\nCLImage2D._wrap = function (context, readOrWriteOnly, format, width, height, hostPtr, rowPitch) {\r\n    var flags = context.cl.defs.CL_MEM_USE_HOST_PTR;\r\n    if (readOrWriteOnly === \"readOnly\") {\r\n        flags |= context.cl.defs.CL_MEM_READ_ONLY;\r\n    }\r\n    else if (readOrWriteOnly === \"writeOnly\") {\r\n        flags |= context.cl.defs.CL_MEM_WRITE_ONLY;\r\n    }\r\n    return new CLImage2D(context, context.cl.defs.CL_MEM_USE_HOST_PTR, format, width, height, hostPtr, rowPitch);\r\n};\r\n\r\nCLImage2D.wrap = function (context, format, width, height, hostPtr, rowPitch) {\r\n    return CLImage2D._wrap(context, null, format, width, height, hostPtr, rowPitch);\r\n};\r\n\r\nCLImage2D.wrapReadOnly = function (context, format, width, height, hostPtr, rowPitch) {\r\n    return CLImage2D._wrap(context, \"readOnly\", format, width, height, hostPtr, rowPitch);\r\n};\r\n\r\nCLImage2D.wrapWriteOnly = function (context, format, width, height, hostPtr, rowPitch) {\r\n    return CLImage2D._wrap(context, \"writeOnly\", format, width, height, hostPtr, rowPitch);\r\n};\r\n\r\nutil.inherits(CLImage2D, CLImage);\r\n\r\nmodule.exports = CLImage2D;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clImage.js":"\"use strict\";\r\n\r\nvar util = require(\"util\");\r\nvar CLMemory = require(\"./clMemory\");\r\n\r\nfunction CLImage(context, handle) {\r\n    CLMemory.call(this, context, handle);\r\n}\r\n\r\nutil.inherits(CLImage, CLMemory);\r\n\r\nObject.defineProperties(CLImage.prototype, {\r\n    //!image format descriptor specified when image was created\r\n    format: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, this.cl.types.ImageFormat, this.cl.defs.CL_IMAGE_FORMAT);\r\n        }\r\n    },\r\n    /**\r\n     *    size of each element of the image memory object given by image. An\r\n     *    element is made up of n channels. The value of n is given in cl_image_format descriptor.\r\n     */\r\n    elementSize: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"size_t\", this.cl.defs.CL_IMAGE_ELEMENT_SIZE);\r\n        }\r\n    },\r\n    //! size in bytes of a row of elements of the image object given by image\r\n    rowPitch: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"size_t\", this.cl.defs.CL_IMAGE_ROW_PITCH);\r\n        }\r\n    },\r\n    /**\r\n     *    size in bytes of a 2D slice for the 3D image object given by image.\r\n     *\r\n     *    For a 2D image object this value will be 0.\r\n     */\r\n    slicePitch: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"size_t\", this.cl.defs.CL_IMAGE_SLICE_PITCH);\r\n        }\r\n    },\r\n    //! width in pixels\r\n    width: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"size_t\", this.cl.defs.CL_IMAGE_WIDTH);\r\n        }\r\n    },\r\n    //! height in pixels\r\n    height: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"size_t\", this.cl.defs.CL_IMAGE_HEIGHT);\r\n        }\r\n    },\r\n    /**\r\n     *    depth of the image in pixels\r\n     *\r\n     *    For a 2D image object, depth = 0\r\n     */\r\n    depth: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"size_t\", this.cl.defs.CL_IMAGE_DEPTH);\r\n        }\r\n    },\r\n    //! The target argument specified in CLImage2DGL, CLImage3DGL constructors\r\n    textureTarget: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"uint\", this.cl.defs.CL_GL_TEXTURE_TARGET);\r\n        }\r\n    },\r\n    //! The miplevel argument specified in CLImage2DGL, CLImage3DGL constructors\r\n    mipmapLevel: {\r\n        get: function () {\r\n            return this._getInfoWith(this.cl.imports.clGetImageInfo, \"int\", this.cl.defs.CL_GL_MIPMAP_LEVEL);\r\n        }\r\n    }\r\n});\r\n\r\nmodule.exports = CLImage;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clImage3D.js":"\"use strict\";\r\n\r\nvar util = require(\"util\");\r\nvar CLImage = require(\"./clImage\");\r\nvar clUtils = require(\"./clUtils\");\r\nvar clPredef = require(\"./clPredef\");\r\n\r\nfunction CLImage3D(context, flags, format, width, height, depth, hostPtr, rowPitch, slicePitch) {\r\n    format = clUtils.asImageFormat(format);\r\n    hostPtr = hostPtr || null;\r\n    rowPitch = rowPitch || 0;\r\n    slicePitch = slicePitch || 0;\r\n    var cl = context.cl;\r\n\r\n    var err = clPredef.err;\r\n    var handle = cl.imports.clCreateImage3D(clUtils.toHandle(context, \"context\"), flags, format.ref(), width, height, depth, rowPitch, slicePitch, clUtils.toPtr(hostPtr, \"hostPtr\"), err);\r\n    cl.checkError(err);\r\n\r\n    CLImage.call(this, context, handle);\r\n}\r\n\r\nutil.inherits(CLImage3D, CLImage);\r\n\r\nmodule.exports = CLImage3D;","/home/travis/build/npmtest/node-npmtest-nooocl/node_modules/nooocl/lib/clSampler.js":"\"use strict\";\n\nvar CLWrapper = require(\"./clWrapper\");\nvar util = require(\"util\");\nvar fastcall = require(\"fastcall\");\nvar ref = fastcall.ref;\nvar clUtils = require(\"./clUtils\");\n\nfunction createReleaseFunction(cl, handle) {\n    return CLWrapper._releaseFunction(function () {\n        cl.imports.clReleaseSampler(handle);\n    });\n}\n\n/**\n *    creates a sampler object\n *\n *    Params:\n *        normalizedCoords= determines if the image coordinates specified are normalized\n *        addressingMode    = specifies how out-of-range image coordinates are handled when reading from an image\n *        filterMode        = specifies the type of filter that must be applied when reading an image\n */\nfunction CLSampler(context, normalizedCoords, addressingMode, filterMode) {\n    var cl = context.cl;\n    var err = ref.alloc(cl.types.ErrorCode);\n    var handle = cl.imports.clCreateSampler(clUtils.toHandle(context, \"context\"), normalizedCoords, addressingMode, filterMode, err);\n    cl.checkError(err);\n    CLWrapper.call(this, cl, handle, createReleaseFunction(cl, handle));\n    this.context = context;\n}\n\nutil.inherits(CLSampler, CLWrapper);\n\nObject.defineProperties(CLSampler.prototype, {\n    _classInfoFunction: {\n        get: function () {\n            return \"clGetSamplerInfo\";\n        }\n    },\n    normalizedCoords: {\n        get: function () {\n            return this._getInfo(\"bool\", this.cl.defs.CL_SAMPLER_NORMALIZED_COORDS);\n        }\n    },\n\n    addressingMode: {\n        get: function () {\n            return this._getInfo(this.cl.types.AddressingMode, this.cl.defs.CL_SAMPLER_ADDRESSING_MODE);\n        }\n    },\n\n    filterMode: {\n        get: function () {\n            return this._getInfo(this.cl.types.FilterMode, this.cl.defs.CL_SAMPLER_FILTER_MODE);\n        }\n    }\n});\n\nmodule.exports = CLSampler;"}